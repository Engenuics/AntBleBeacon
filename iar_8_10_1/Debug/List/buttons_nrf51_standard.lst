###############################################################################
#
# IAR ANSI C/C++ Compiler V8.10.1.12857/W32 for ARM       29/Jun/2018  00:30:10
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\EiE\EiE Git\AntBleBeacon\bsp\buttons_nrf51_standard.c
#    Command line =  
#        -f C:\Users\ENGENU~1\AppData\Local\Temp\EW5A2E.tmp ("D:\EiE\EiE
#        Git\AntBleBeacon\bsp\buttons_nrf51_standard.c" -D NRF51 -lC
#        "D:\EiE\EiE Git\AntBleBeacon\iar_8_10_1\Debug\List" -o "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR
#        Systems\EWARM_8_10_1\arm\INC\c\DLib_Config_Normal.h" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\bsp\" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\application\" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\" -I
#        "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\s310\" -I
#        "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\ble\" -I
#        "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\ble\ble_services\"
#        -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\ble\device_manager\"
#        -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\app_common\"
#        -On --require_prototypes -I "C:\Program Files\IAR
#        Systems\EWARM_8_10_1\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\Debug\List\buttons_nrf51_standard.lst
#    Object file  =  
#        D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\Debug\Obj\buttons_nrf51_standard.o
#
###############################################################################

D:\EiE\EiE Git\AntBleBeacon\bsp\buttons_nrf51_standard.c
      1          /*!**********************************************************************************************************************
      2          @file buttons_nrf51_standard.c                                                                
      3          @brief Button functions and state machine.  
      4          
      5          The application handles all debouncing and button press / hold detection for buttons
      6          used on development boards with the nRF51 processor.  All buttons use dedicated
      7          hardwware lines (active high or active low), with interrupts to trigger the 
      8          start and end of the action.
      9          
     10          ------------------------------------------------------------------------------------------------------------------------
     11          GLOBALS
     12          - NONE
     13          
     14          CONSTANTS
     15          - U32_DEBOUNCE_TIME
     16          
     17          TYPES
     18          - enum ButtonStateType
     19          - struct ButtonStatusType
     20          
     21          PUBLIC FUNCTIONS
     22          - bool IsButtonPressed(ButtonNameType eButton_)
     23          - bool WasButtonPressed(ButtonNameType eButton_)
     24          - void ButtonAcknowledge(ButtonNameType eButton_)
     25          - bool IsButtonHeld(ButtonNameType eButton_, u32 u32ButtonHeldTime_)
     26          
     27          PROTECTED FUNCTIONS
     28          - void ButtonInitialize(void)
     29          - void ButtonRunActiveState(void)
     30          - void ButtonStartDebounce(u32 u32BitPosition_, PortOffsetType ePort_)
     31          
     32          
     33          ***********************************************************************************************************************/
     34          
     35          #include "configuration.h"

                GPIOE_TASK0  = 0, GPIOE_TASK0  = 1, GPIOE_TASK0  = 2, GPIOE_TASK0  = 3, 
                                  ^
"D:\EiE\EiE Git\AntBleBeacon\application\typedefs.h",65  Error[Pe101]: 
          "GPIOE_TASK0" has already been declared in the current scope (at line
          65)

                GPIOE_TASK0  = 0, GPIOE_TASK0  = 1, GPIOE_TASK0  = 2, GPIOE_TASK0  = 3, 
                                                    ^
"D:\EiE\EiE Git\AntBleBeacon\application\typedefs.h",65  Error[Pe101]: 
          "GPIOE_TASK0" has already been declared in the current scope (at line
          65)

                GPIOE_TASK0  = 0, GPIOE_TASK0  = 1, GPIOE_TASK0  = 2, GPIOE_TASK0  = 3, 
                                                                      ^
"D:\EiE\EiE Git\AntBleBeacon\application\typedefs.h",65  Error[Pe101]: 
          "GPIOE_TASK0" has already been declared in the current scope (at line
          65)

  void LedOn(LedNumberType eLED_);
             ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",76  Error[Pe020]: identifier
          "LedNumberType" is undefined

  void LedOff(LedNumberType eLED_);
              ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",77  Error[Pe020]: identifier
          "LedNumberType" is undefined

  void LedToggle(LedNumberType eLED_);
                 ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",78  Error[Pe020]: identifier
          "LedNumberType" is undefined

  void LedPWM(LedNumberType eLED_, LedRateType ePwmRate_);
              ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",79  Error[Pe020]: identifier
          "LedNumberType" is undefined

  void LedBlink(LedNumberType eLED_, LedRateType ePwmRate_);
                ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",80  Error[Pe020]: identifier
          "LedNumberType" is undefined
     36          
     37          /***********************************************************************************************************************
     38          Global variable definitions with scope across entire project.
     39          All Global variable names shall start with "G_<type>Button"
     40          ***********************************************************************************************************************/
     41          /* New variables */
     42          
     43          
     44          /*--------------------------------------------------------------------------------------------------------------------*/
     45          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     46          extern volatile u32 G_u32SystemTime1ms;                /*!< @brief From main.c */
     47          extern volatile u32 G_u32SystemTime1s;                 /*!< @brief From main.c */
     48          extern volatile u32 G_u32SystemFlags;                  /*!< @brief From main.c */
     49          
     50          extern const PinConfigurationType G_asBspButtonConfigurations[U8_TOTAL_BUTTONS]; /*!< @brief from board-specific file */
                              ^
Error[Pe020]: identifier "PinConfigurationType" is undefined
     51          
     52          
     53          /***********************************************************************************************************************
     54          Global variable definitions with scope limited to this local application.
     55          Variable names shall start with "Button_<type>" and be declared as static.
     56          ***********************************************************************************************************************/
     57          static fnCode_type Button_pfnStateMachine;                  /* The Button application state machine function pointer */
     58          
     59          static ButtonStatusType Button_asStatus[U8_TOTAL_BUTTONS];  /*!< @brief Individual status parameters for buttons */
     60          
     61          #if 0
     62          static ButtonStateType Button_aeCurrentState[TOTAL_BUTTONS];/* Current pressed state of button */
     63          static ButtonStateType Button_aeNewState[TOTAL_BUTTONS];    /* New (pending) pressed state of button */
     64          static u32 Button_au32HoldTimeStart[TOTAL_BUTTONS];         /* System 1ms time when a button press started */
     65          static bool Button_abNewPress[TOTAL_BUTTONS];               /* Flags to indicate a button was pressed */    
     66          static u8 Button_u8ActiveCol;                               /* Current Active Button Column */                                                                                    
     67          #endif
     68          
     69          
     70          /***********************************************************************************************************************
     71          Function Definitions
     72          ***********************************************************************************************************************/
     73          
     74          /*------------------------------------------------------------------------------------------------------------------*/
     75          /*! @publicsection */                                                                                            
     76          /*--------------------------------------------------------------------------------------------------------------------*/
     77          
     78          /*!----------------------------------------------------------------------------------------------------------------------
     79          @fn bool IsButtonPressed(ButtonNameType eButton_)
     80          
     81          @brief Determine if a particular button is currently pressed at the moment in time when 
     82          the function is called.
     83          
     84          The button must still be pressed at the time of this inquiry for the function
     85          to return TRUE.
     86          
     87          Requires:
     88          - Button_asStatus[eButton_] is a valid index
     89          
     90          @param eButton_ is a valid button 
     91           
     92          Promises:
     93          - Returns TRUE if Button_asStatus[eButton_].eCurrentState is PRESSED 
     94          - Otherwise returns FALSE
     95          
     96          */
     97          bool IsButtonPressed(ButtonNameType eButton_)
                      ^
Error[Pe147]: declaration is incompatible with "__interwork __softfp _Bool
          IsButtonPressed(u32)" (declared at line 49 of "D:\EiE\EiE
          Git\AntBleBeacon\bsp\buttons_nrf51_standard.h")
     98          {
     99            if( Button_asStatus[(u8)eButton_].eCurrentState == PRESSED)
    100            {
    101              return(TRUE);
    102            }
    103            else
    104            {
    105              return(FALSE);
    106            }
    107          
    108          } /* end IsButtonPressed() */
    109          
    110          
    111          /*!----------------------------------------------------------------------------------------------------------------------
    112          @fn bool WasButtonPressed(ButtonNameType eButton_)
    113          
    114          @brief Determines if a particular button was pressed since last time it was checked. 
    115          
    116          This is effectively a latching function so that button presses are
    117          not missed and are potentially available to multiple tasks.
    118          
    119          The button may or may not still be pressed when this inquiry is made.  Mulitple
    120          button presses are not tracked.  The user should call ButtonAcknowledge immediately
    121          following this function to clear the state. If multiple tasks need the button 
    122          information, only the last function should call ButtonAcknowledge.
    123          
    124          Requires:
    125          - Button_asStatus[eButton_] is a valid index
    126          
    127          @param eButton_ is a valid button 
    128           
    129          Promises:
    130          - Returns TRUE if Button_asStatus[eButton_].bNewPressFlag is TRUE 
    131          - Otherwise returns FALSE
    132          
    133          */
    134          bool WasButtonPressed(ButtonNameType eButton_)
                      ^
Error[Pe147]: declaration is incompatible with "__interwork __softfp _Bool
          WasButtonPressed(u32)" (declared at line 50 of "D:\EiE\EiE
          Git\AntBleBeacon\bsp\buttons_nrf51_standard.h")
    135          {
    136            if( Button_asStatus[(u8)eButton_].bNewPressFlag == TRUE)
    137            {
    138              return(TRUE);
    139            }
    140            else
    141            {
    142              return(FALSE);
    143            }
    144          
    145          } /* end WasButtonPressed() */
    146          
    147          
    148          /*!----------------------------------------------------------------------------------------------------------------------
    149          @fn void ButtonAcknowledge(ButtonNameType eButton_)
    150          
    151          @brief Clears the "New Press" flag of a button so WasButtonPressed() no longer returns TRUE
    152          unless a new button press occurs.
    153          
    154          This function is generally always called after WasButtonPressed() returns TRUE unless 
    155          it is known that other tasks may need the button pressed information.
    156          
    157          Requires:
    158          @param eButton_ is a valid button index
    159           
    160          Promises:
    161          - The flag at Button_asStatus[eButton_].bNewPressFlag is set to FALSE
    162          
    163          */
    164          void ButtonAcknowledge(ButtonNameType eButton_)
                      ^
Error[Pe147]: declaration is incompatible with "__interwork __softfp void
          ButtonAcknowledge(u32)" (declared at line 51 of "D:\EiE\EiE
          Git\AntBleBeacon\bsp\buttons_nrf51_standard.h")
    165          {
    166            Button_asStatus[(u8)eButton_].bNewPressFlag = FALSE;
    167          
    168          } /* end ButtonAcknowledge() */
    169          
    170          
    171          /*!----------------------------------------------------------------------------------------------------------------------
    172          @fn bool IsButtonHeld(ButtonNameType eButton_, u32 u32ButtonHeldTime_)
    173          
    174          @brief Queries to see if a button has been held for a certain time.  
    175          
    176          The button must still be pressed when this function is called if it is to return TRUE.
    177          This is a non-latching function.
    178          
    179          Requires:
    180          @param eButton_ is a valid button index
    181          @param u32ButtonHeldTime is a time in ms 
    182           
    183          Promises:
    184          - Returns TRUE if eButton_ has been held longer than u32ButtonHeldTime_
    185          - Otherwise returns FALSE
    186          
    187          */
    188          bool IsButtonHeld(ButtonNameType eButton_, u32 u32ButtonHeldTime_)
                      ^
Error[Pe147]: declaration is incompatible with "__interwork __softfp _Bool
          IsButtonHeld(u32, u32)" (declared at line 52 of "D:\EiE\EiE
          Git\AntBleBeacon\bsp\buttons_nrf51_standard.h")
    189          {
    190           if( (Button_asStatus[(u8)eButton_].eCurrentState == PRESSED) && 
    191                IsTimeUp(&Button_asStatus[eButton_].u32DebounceTimeStart, u32ButtonHeldTime_ ) )
    192           {
    193             return(TRUE);
    194           }
    195           else
    196           {
    197             return(FALSE);
    198           }
    199          
    200          } /* end IsButtonHeld() */
    201          
    202          
    203          /*--------------------------------------------------------------------------------------------------------------------*/
    204          /* Protected Functions */
    205          /*--------------------------------------------------------------------------------------------------------------------*/
    206          
    207          /*!----------------------------------------------------------------------------------------------------------------------
    208          @fn void ButtonInitialize(void)
    209          
    210          @brief Runs required initialization for the task.  
    211          
    212          Should only be called once in main init section.
    213          Configures the button system for the product including enabling button GPIO interrupts.  
    214          
    215          Requires:
    216          - GPIO configuration is already complete for all button inputs
    217          - Button interrupt initializations and handler functions are ready
    218           
    219          Promises:
    220          - G_abButtonDebounceActive, LGaeButtonPreviousState and Button_aeCurrentState 
    221            are intialized
    222          - GGstButtonTrackballPosition fields are all initialized to default values
    223          - The button state machine is initialized to Idle
    224          
    225          */
    226          void ButtonInitialize(void)
    227          {
    228            /* Setup default data and interrupts for all of the buttons in the system */
    229            for(u8 i = 0; i < U8_TOTAL_BUTTONS; i++)
    230            {
    231              /* Default status data */
    232              Button_asStatus[i].bNewPressFlag = FALSE;
    233              Button_asStatus[i].eCurrentState = RELEASED;
    234              Button_asStatus[i].eNewState     = RELEASED;
    235              Button_asStatus[i].u32TimeStamp  = 0;
    236          
    237              /* Event configuration for toggle events */
    238              nrf_gpiote_event_config(G_asBspButtonConfigurations[i].eChannelNumber, 
    239                                      G_asBspButtonConfigurations[i].u8PinNumber, 
    240                                      NRF_GPIOTE_POLARITY_TOGGLE);
    241              
    242              /* GPIOE Interrupt setup */
    243              if(G_asBspButtonConfigurations[i].eChannelNumber != GPIOE_NO_CHANNEL)
    244              {
    245                NRF_GPIOTE->INTENSET = G_asBspButtonConfigurations[i].u32GpioeChannelBit; 
    246              }
    247            }
    248            
    249            /* Init complete: set function pointer */
    250            Button_pfnStateMachine = ButtonSM_Idle;
    251            
    252           } /* end ButtonInitialize() */
    253          
    254          
    255          /*----------------------------------------------------------------------------------------------------------------------
    256          Function ButtonRunActiveState()
    257          
    258          Description:
    259          Selects and runs one iteration of the current state in the state machine.
    260          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    261          may take 1ms / n to execute.
    262          
    263          Requires:
    264            - State machine function pointer points at current state
    265          
    266          Promises:
    267            - Calls the function to pointed by the state machine function pointer
    268          */
    269          void ButtonRunActiveState(void)
    270          {
    271            Button_pfnStateMachine();
    272          
    273          } /* end ButtonRunActiveState */
    274          
    275          
    276          #if 0
    277          /*!----------------------------------------------------------------------------------------------------------------------
    278          @fn void ButtonStartDebounce(u32 u32BitPosition_, PortOffsetType ePort_)
    279          
    280          @brief Called only from ISR: sets the "debounce active" flag and debounce start time  
    281          
    282          Requires:
    283          - Only the PIOA or PIOB ISR should call this function
    284          
    285          @param u32BitPosition_ is a SINGLE bit and actual button location on which to start debouncing
    286          @param ePort_ is the port on which the button is located
    287          
    288          Promises:
    289          - If the indicated button is found in G_asBspButtonConfigurations, then the
    290          corresponding interrupt is disabled and debounce information is set in Button_asStatus
    291          
    292          */
    293          void ButtonStartDebounce(u32 u32BitPosition_)
    294          {
    295            ButtonNameType eButton = NOBUTTON;
    296            
    297            /* Parse through to find the button */
    298            for(u8 i = 0; i < U8_TOTAL_BUTTONS; i++)
    299            {
    300              if(G_asBspButtonConfigurations[i].u32BitPosition == u32BitPosition_)
    301              {
    302                eButton = (ButtonNameType)i;
    303                break;
    304              }
    305            }
    306            
    307            /* If the button has been found, disable the interrupt and update debounce status */
    308            if(eButton != NOBUTTON)
    309            {
    310              NRF_GPIOTE->INTENCLR = G_asBspButtonConfigurations[eButton].eChannelNumber]);
    311              Button_asStatus[(u8)eButton].bDebounceActive = TRUE;
    312              Button_asStatus[(u8)eButton].u32DebounceTimeStart = G_u32SystemTime1ms;
    313            }
    314            
    315          } /* end ButtonStartDebounce() */
    316          #endif
    317          
    318          
    319          /*------------------------------------------------------------------------------------------------------------------*/
    320          /*! @privatesection */                                                                                            
    321          /*--------------------------------------------------------------------------------------------------------------------*/
    322          
    323          
    324          /***********************************************************************************************************************
    325          State Machine Function Definitions
    326          
    327          The button state machine monitors button activity and manages debouncing and
    328          maintaining the global button states.
    329          ***********************************************************************************************************************/
    330          
    331          /*!-------------------------------------------------------------------------------------------------------------------
    332          @fn static void ButtonSM_Idle(void)
    333          
    334          @brief Look for at least one button to enter debouncing state
    335          */
    336          static void ButtonSM_Idle(void)                
    337          {
    338            for(u8 i = 0; i < U8_TOTAL_BUTTONS; i++)
    339            {
    340              if(Button_asStatus[i].bDebounceActive)
    341              {
    342                Button_pfnStateMachine = ButtonSM_ButtonActive;
    343                break;
    344              }
    345            }
    346            
    347          } /* end ButtonSM_Idle(void) */
    348          
    349          
    350          
    351          /*!-------------------------------------------------------------------------------------------------------------------
    352          @fn static void ButtonSM_ButtonActive(void)
    353          
    354          @brief Process each button that is debouncing.
    355          
    356          Time out the debounce period and set the "pressed" state if button action is confirmed.
    357          Manage the hold timers.
    358          */
    359          static void ButtonSM_ButtonActive(void)         
    360          {
    361          //  u32 *pu32PortAddress;
    362          //  u32 *pu32InterruptAddress;
    363            u32 u32Input;
    364          
    365            /* Start by resetting back to Idle in case no buttons are active */
    366            Button_pfnStateMachine = ButtonSM_Idle;
    367          
    368            /* Check for buttons that are debouncing */
    369            for(u8 i = 0; i < U8_TOTAL_BUTTONS; i++)
    370            {
    371              /* Load address offsets for the current button */
    372          //    pu32PortAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_PDSR) + G_asBspButtonConfigurations[i].ePort);
    373          //    pu32InterruptAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_IER) + G_asBspButtonConfigurations[i].ePort);
    374              
    375              /* Check if the current button is debouncing */
    376              if( Button_asStatus[i].bDebounceActive )
    377              {
    378                /* Still have an active button */
    379                Button_pfnStateMachine = ButtonSM_ButtonActive;
    380                
    381                /* Check if debounce period is over */
    382                if( IsTimeUp(&Button_asStatus[i].u32DebounceTimeStart, U32_DEBOUNCE_TIME) )
                                                                              ^
Error[Pe020]: identifier "U32_DEBOUNCE_TIME" is undefined
    383                {
    384                  /* Read the pin state and invert for ACTIVE_LOW */
    385                  u32Input = NRF_GPIO->IN;
    386                  if(G_asBspButtonConfigurations[i].eActiveState == ACTIVE_LOW)
    387                  {
    388                    u32Input = ~u32Input;
    389                  }
    390                  
    391                  /* Mask the bit of interest to check its state */
    392                  if( u32Input & G_asBspButtonConfigurations[i].u32BitPosition )
    393                  {          
    394                    Button_asStatus[i].eNewState = PRESSED;
    395                  }
    396                  else
    397                  {
    398                    Button_asStatus[i].eNewState = RELEASED;
    399                  }
    400                  
    401                  /* Update if the button state has changed */
    402                  if( Button_asStatus[i].eNewState != Button_asStatus[i].eCurrentState )
    403                  {
    404                    Button_asStatus[i].eCurrentState = Button_asStatus[i].eNewState;
    405                    
    406                    /* If the new state is PRESSED, update the new press flag */
    407                    if(Button_asStatus[i].eCurrentState == PRESSED)
    408                    {
    409                      Button_asStatus[i].bNewPressFlag = TRUE;
    410                      Button_asStatus[i].u32TimeStamp  = G_u32SystemTime1ms;
    411                    }
    412                  }
    413          
    414                  /* Regardless of a good press or not, clear the debounce active flag and re-enable the interrupts */
    415                  Button_asStatus[i].bDebounceActive = FALSE;
    416                  NRF_GPIOTE->INTENSET = G_asBspButtonConfigurations[i].u32GpioeChannelBit;
    417                  
    418                } /* end if( IsTimeUp...) */
    419              } /* end if(Button_asStatus[i].bDebounceActive) */
    420            } /* end for (u8 i = 0; i < U8_TOTAL_BUTTONS; i++) */
    421            
    422          } /* end ButtonSM_ButtonActive() */
    423          
    424          
    425          
    426          
    427          
    428          /*--------------------------------------------------------------------------------------------------------------------*/
    429          /* End of File */
    430          /*--------------------------------------------------------------------------------------------------------------------*/

Errors: 14
Warnings: none
