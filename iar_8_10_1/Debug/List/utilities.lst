###############################################################################
#
# IAR ANSI C/C++ Compiler V8.10.1.12857/W32 for ARM       29/Jun/2018  00:30:11
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\EiE\EiE Git\AntBleBeacon\bsp\utilities.c
#    Command line =  
#        -f C:\Users\ENGENU~1\AppData\Local\Temp\EW5F15.tmp ("D:\EiE\EiE
#        Git\AntBleBeacon\bsp\utilities.c" -D NRF51 -lC "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\Debug\List" -o "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR
#        Systems\EWARM_8_10_1\arm\INC\c\DLib_Config_Normal.h" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\bsp\" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\application\" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\" -I
#        "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\s310\" -I
#        "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\ble\" -I
#        "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\ble\ble_services\"
#        -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\ble\device_manager\"
#        -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\app_common\"
#        -On --require_prototypes -I "C:\Program Files\IAR
#        Systems\EWARM_8_10_1\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        D:\EiE\EiE Git\AntBleBeacon\iar_8_10_1\Debug\List\utilities.lst
#    Object file  =  
#        D:\EiE\EiE Git\AntBleBeacon\iar_8_10_1\Debug\Obj\utilities.o
#
###############################################################################

D:\EiE\EiE Git\AntBleBeacon\bsp\utilities.c
      1          /***********************************************************************************************************************
      2          File: utilities.c                                                                
      3          
      4          Description:
      5          Various useful functions.
      6          ***********************************************************************************************************************/
      7          
      8          #include "configuration.h"

                GPIOE_TASK0  = 0, GPIOE_TASK0  = 1, GPIOE_TASK0  = 2, GPIOE_TASK0  = 3, 
                                  ^
"D:\EiE\EiE Git\AntBleBeacon\application\typedefs.h",65  Error[Pe101]: 
          "GPIOE_TASK0" has already been declared in the current scope (at line
          65)

                GPIOE_TASK0  = 0, GPIOE_TASK0  = 1, GPIOE_TASK0  = 2, GPIOE_TASK0  = 3, 
                                                    ^
"D:\EiE\EiE Git\AntBleBeacon\application\typedefs.h",65  Error[Pe101]: 
          "GPIOE_TASK0" has already been declared in the current scope (at line
          65)

                GPIOE_TASK0  = 0, GPIOE_TASK0  = 1, GPIOE_TASK0  = 2, GPIOE_TASK0  = 3, 
                                                                      ^
"D:\EiE\EiE Git\AntBleBeacon\application\typedefs.h",65  Error[Pe101]: 
          "GPIOE_TASK0" has already been declared in the current scope (at line
          65)

  void LedOn(LedNumberType eLED_);
             ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",76  Error[Pe020]: identifier
          "LedNumberType" is undefined

  void LedOff(LedNumberType eLED_);
              ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",77  Error[Pe020]: identifier
          "LedNumberType" is undefined

  void LedToggle(LedNumberType eLED_);
                 ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",78  Error[Pe020]: identifier
          "LedNumberType" is undefined

  void LedPWM(LedNumberType eLED_, LedRateType ePwmRate_);
              ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",79  Error[Pe020]: identifier
          "LedNumberType" is undefined

  void LedBlink(LedNumberType eLED_, LedRateType ePwmRate_);
                ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",80  Error[Pe020]: identifier
          "LedNumberType" is undefined
      9          
     10          /***********************************************************************************************************************
     11          Global variable definitions with scope across entire project.
     12          All Global variable names shall start with "G_"
     13          ***********************************************************************************************************************/
     14          /* New variables */
     15          u8 G_au8MessageOK[]   = MESSAGE_OK;            /* Common "OK" message */
     16          u8 G_au8MessageFAIL[] = MESSAGE_FAIL;          /* Common "FAIL" message */
     17          u8 G_au8MessageON[]   = MESSAGE_ON;            /* Common "ON" message */
     18          u8 G_au8MessageOFF[]  = MESSAGE_OFF;           /* Common "OFF" message */
     19          
     20          
     21          /*--------------------------------------------------------------------------------------------------------------------*/
     22          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     23          extern volatile u32 G_u32SystemTime1ms;        /* From scroll-ehw-ae.c */
     24          extern volatile u32 G_u32SystemTime1s;         /* From scroll-ehw-ae.c */
     25          
     26          extern volatile u32 G_u32SystemFlags;          /* From main.c */
     27          extern volatile u32 G_u32ApplicationFlags;     /* From main.c */
     28          
     29          
     30          /***********************************************************************************************************************
     31          Global variable definitions with scope limited to this local application.
     32          Variable names shall start with "Util_" and be declared as static.
     33          ***********************************************************************************************************************/
     34          
     35          
     36          /***********************************************************************************************************************
     37          Function Definitions
     38          ***********************************************************************************************************************/
     39          /*--------------------------------------------------------------------------------------------------------------------*/
     40          /* Public Functions */
     41          /*--------------------------------------------------------------------------------------------------------------------*/
     42          
     43          /*----------------------------------------------------------------------------
     44          Function: IsTimeUp
     45            
     46          Description:
     47          Checks if the difference between the current time and the saved time is greater
     48          than the period specified. The referenced current time is always G_u32SystemTime1ms.
     49          
     50          Requires:
     51            - *pu32SavedTick_ points to the saved tick value (in ms)
     52            - u32Period_ is the desired period in ms
     53          
     54          Promises:
     55            - Returns false if u32Period_ has not elapsed
     56            - Returns true if u32Period_ has elapsed
     57          */
     58          bool IsTimeUp(u32 *pu32SavedTick_, u32 u32Period_)
     59          {
     60            u32 u32TimeElapsed;
     61            
     62            /* Check to see if the timer in question has rolled */
     63            if(G_u32SystemTime1ms >= *pu32SavedTick_)
     64            {
     65              u32TimeElapsed = G_u32SystemTime1ms - *pu32SavedTick_;
     66            }
     67            else
     68            {
     69              u32TimeElapsed = (0xFFFFFFFF - *pu32SavedTick_) + G_u32SystemTime1ms;
     70            }
     71          
     72            /* Now determine if time is up */
     73            if(u32TimeElapsed < u32Period_)
     74            {
     75              return(false);
     76            }
     77            else
     78            {
     79              return(true);
     80            }
     81          
     82          } /* end IsTimeUp() */
     83          
     84          
     85          /*-----------------------------------------------------------------------------/
     86          Function: ASCIIHexCharToChar
     87          
     88          Description:
     89          Determines the numerical value of a hexidecimal ASCII char of that number
     90          ('0' - 'F' or '0' - 'f' -> 0 - 15).
     91          
     92          Requires:
     93            - Standard ASCII table is in use
     94           
     95          Promises:
     96            - If valid 0-9, A-F or a-f, returns the numerical value of the ASCII char
     97            - Otherwise returns 0xff
     98          */
     99          u8 ASCIIHexCharToChar(u8 u8Char_)
    100          {
    101            if( (u8Char_ >= '0') && (u8Char_ <= '9') )
    102              return(u8Char_ - NUMBER_ASCII_TO_DEC);
    103                 
    104            if( (u8Char_ >= 'A') && (u8Char_ <= 'F') )
    105              return(u8Char_ - UPPERCASE_ASCII_TO_DEC);
    106            
    107            if( (u8Char_ >= 'a') && (u8Char_ <= 'f') )
    108              return(u8Char_ - LOWERCASE_ASCII_TO_DEC);
    109            
    110            return(0xff);
    111          
    112          } /* end ASCIIHexChartoChar */
    113          
    114          
    115          /*-----------------------------------------------------------------------------/
    116          Function: HexToASCIICharUpper
    117          
    118          Description:
    119          Determines the ASCII char of a single digit number
    120          0 - 15 -> '0' - 'F'
    121          
    122          Requires:
    123            - Standard ASCII table is in use
    124           
    125          Promises:
    126            - If valid 0-15, returns the corresponding ASCII hex char 0-9, A-F
    127            - Otherwise returns 0xff
    128          */
    129          u8 HexToASCIICharUpper(u8 u8Char_)
    130          {
    131            u8 u8ReturnValue = 0xFF;
    132            
    133            if( u8Char_ <= 9 )
    134            {
    135              u8ReturnValue = u8Char_ + NUMBER_ASCII_TO_DEC;
    136            }
    137            
    138            else if( (u8Char_ >= 10) && (u8Char_ <= 15) )
    139            {
    140              u8ReturnValue = u8Char_ + UPPERCASE_ASCII_TO_DEC;
    141            }
    142            
    143            return(u8ReturnValue);
    144          
    145          } /* end HexToASCIICharUpper */
    146          
    147          
    148          /*-----------------------------------------------------------------------------/
    149          Function: HexToASCIICharLower
    150          
    151          Description:
    152          Determines the ASCII char of a single digit number
    153          0 - 15 -> '0' - 'f'
    154          
    155          Requires:
    156            - Standard ASCII table is in use
    157           
    158          Promises:
    159            - If valid 0-15, returns the corresponding ASCII hex char 0-9, a-f
    160            - Otherwise returns 0xFF
    161          */
    162          u8 HexToASCIICharLower(u8 u8Char_)
    163          {
    164            u8 u8ReturnValue = 0xFF;
    165            
    166            if( u8Char_ <= 9 )
    167            {
    168              u8ReturnValue = u8Char_ + NUMBER_ASCII_TO_DEC;
    169            }
    170            
    171            else if( (u8Char_ >= 10) && (u8Char_ <= 15) )
    172            {
    173              u8ReturnValue = u8Char_ + LOWERCASE_ASCII_TO_DEC;
    174            }
    175            
    176            return(u8ReturnValue);
    177          
    178          } /* end HexToASCIICharLower */
    179          
    180          
    181          /*-----------------------------------------------------------------------------/
    182          Function: NumberToAscii
    183          
    184          Description:
    185          Converts a long into an ASCII string.  Maximum of 10 digits + NULL.
    186          
    187          Requires:
    188            - u32Number_ is the number to convert
    189            - *pu8AsciiString_ points to the destination string location
    190           
    191          Promises:
    192            - Null-terminated string of the number is loaded to pu8AsciiString_
    193            - Returns the number of digits
    194          */
    195          u8 NumberToAscii(u32 u32Number_, u8* pu8AsciiString_)
    196          {
    197            bool bFoundDigit = false;
    198            u8 au8AsciiNumber[11];
    199            u8 u8CharCount = 0;
    200            u32 u32Divider = 1000000000;
    201            u8 u8Temp;
    202            
    203            /* Parse out all the digits, start counting after leading zeros */
    204            for(u8 i = 0; i < 10; i++)
    205            {
    206              u8Temp = (u32Number_ / u32Divider);
    207              
    208              /* Check for first non-leading zero */
    209              if(u8Temp != 0)
    210              {
    211                bFoundDigit = true;
    212              }
    213          
    214              /* As long as a non-leading zero has been found, add the ASCII char */
    215              if(bFoundDigit)
    216              {
    217                au8AsciiNumber[u8CharCount] = u8Temp + 0x30;
    218                u8CharCount++;
    219              }
    220              
    221              /* Update for next iteration */
    222              u32Number_ %= u32Divider;
    223              u32Divider /= 10;
    224            }
    225            
    226            /* Handle special case where u32Number == 0 */
    227            if(!bFoundDigit)
    228            {
    229              u8CharCount = 1;
    230              au8AsciiNumber[0] = '0';
    231            }
    232            
    233            /* Add the null and copy to destination */
    234            au8AsciiNumber[u8CharCount] = NULL;
    235            strcpy((char *)pu8AsciiString_, (const char*)au8AsciiNumber);
    236            
    237            return(u8CharCount);
    238          
    239          } /* end NumberToAscii() */
    240          
    241          
    242          /*-----------------------------------------------------------------------------/
    243          Function: SearchString
    244          
    245          Description:
    246          Searches a string for another string.  Finds only an exact match of the string (case sensitive).
    247          Character following matched string must be space, <CR> or <LF>.
    248          
    249          Requires:
    250            - Standard ASCII table is in use
    251            - pu8TargetString_ points to the start of a NULL, <CR> or <LF> terminated string to search
    252            - pu8MatchString_ points to the start of a NULL, <CR> or <LF> terminated string to be found in pu8TargetString_
    253           
    254          Promises:
    255            - Returns true if the string is found
    256          */
    257          bool SearchString(u8* pu8TargetString_, u8* pu8MatchString_)
    258          {
    259            u8* pu8MatchChar = pu8MatchString_;
    260            u8* pu8TargetChar = pu8TargetString_;
    261            
    262            do
    263            {
    264              /* Scan for the current character of pu8MatchString_ in pu8TargetString_ */
    265              while( (*pu8MatchChar != *pu8TargetChar) && (*pu8TargetChar != NULL) && 
    266                     (*pu8TargetChar != ASCII_LINEFEED) && (*pu8TargetChar != ASCII_CARRIAGE_RETURN) )
    267              {
    268                pu8TargetChar++;
    269              }
    270              
    271              /* Exit if we're at the end of the target string */
    272              if( (*pu8TargetChar == NULL) || 
    273                  (*pu8TargetChar == ASCII_LINEFEED) || (*pu8TargetChar == ASCII_CARRIAGE_RETURN) )
    274              {
    275                return(false);
    276              }
    277              
    278              /* If we found a match, look for next char */
    279              while ( *pu8MatchChar == *pu8TargetChar )
    280              {
    281                pu8MatchChar++;
    282                pu8TargetChar++;
    283                
    284                /* At the end of the match string? */
    285                if( (*pu8MatchChar == NULL) || (*pu8MatchChar == ASCII_LINEFEED) || (*pu8MatchChar == ASCII_CARRIAGE_RETURN) )
    286                {
    287                  /* Check if the next character in pu8TargetChar is space, <CR>, <LF> or ':' */
    288                  if( (*pu8TargetChar == ' ') ||
    289                      (*pu8TargetChar == ASCII_CARRIAGE_RETURN) ||
    290                      (*pu8TargetChar == ASCII_LINEFEED) ||
    291                      (*pu8TargetChar == ':')  )
    292                  {
    293                    return(true);
    294                  }
    295                }
    296              }
    297          
    298              /* At the end of the target string? */
    299              if( (*pu8TargetChar == NULL) || (*pu8TargetChar == ASCII_LINEFEED) || (*pu8TargetChar == ASCII_CARRIAGE_RETURN) )
    300              {
    301                return(false);
    302              }
    303              
    304              /* If here, match was not found (yet), but as long as there are more characters in pu8TargetChar,
    305              then we can scan again. */
    306              
    307              /* Reset match pointer back to the start of its string */
    308              pu8MatchChar = pu8MatchString_;
    309            } while ( (*pu8TargetChar != NULL) && 
    310                      (*pu8TargetChar != ASCII_LINEFEED) && (*pu8TargetChar != ASCII_CARRIAGE_RETURN) );
    311            
    312            /* If we get here, no match was found */
    313            return(false);
    314          
    315          } /* end SearchString */
    316          
    317          
    318          /*--------------------------------------------------------------------------------------------------------------------*/
    319          /* Protected Functions */
    320          /*--------------------------------------------------------------------------------------------------------------------*/
    321          
    322          /*--------------------------------------------------------------------------------------------------------------------*/
    323          /* Private functions */
    324          /*--------------------------------------------------------------------------------------------------------------------*/
    325          
    326          
    327          
    328          
    329          /*--------------------------------------------------------------------------------------------------------------------*/
    330          /* End of File */
    331          /*--------------------------------------------------------------------------------------------------------------------*/

Errors: 8
Warnings: none
