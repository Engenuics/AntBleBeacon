###############################################################################
#
# IAR ANSI C/C++ Compiler V8.10.1.12857/W32 for ARM       29/Jun/2018  00:30:11
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c
#    Command line =  
#        -f C:\Users\ENGENU~1\AppData\Local\Temp\EW5C53.tmp ("D:\EiE\EiE
#        Git\AntBleBeacon\bsp\leds_nrf51.c" -D NRF51 -lC "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\Debug\List" -o "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\Debug\Obj" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR
#        Systems\EWARM_8_10_1\arm\INC\c\DLib_Config_Normal.h" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\bsp\" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\application\" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\" -I
#        "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\s310\" -I
#        "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\ble\" -I
#        "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\ble\ble_services\"
#        -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\ble\device_manager\"
#        -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_8_10_1\..\nordic_sdk6_1_0\Include\app_common\"
#        -On --require_prototypes -I "C:\Program Files\IAR
#        Systems\EWARM_8_10_1\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        D:\EiE\EiE Git\AntBleBeacon\iar_8_10_1\Debug\List\leds_nrf51.lst
#    Object file  =  
#        D:\EiE\EiE Git\AntBleBeacon\iar_8_10_1\Debug\Obj\leds_nrf51.o
#
###############################################################################

D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c
      1          /*!**********************************************************************************************************************
      2          @file leds_nrf51.c                                                                
      3          @brief LED driver that provides on, off, toggle, blink and PWM functionality.
      4          
      5          The basic on/off/toggle functionality is applied directly to the LEDs.
      6          Blinking and PWMing of LEDs rely on a 1ms system tick to provide timing at
      7          regular 1ms calls to LedUpdate().
      8          
      9          This driver relies on a standard LED 
     10          
     11          ------------------------------------------------------------------------------------------------------------------------
     12          GLOBALS
     13          - NONE
     14          
     15          CONSTANTS
     16          - NONE
     17          
     18          TYPES
     19          - LedNameType (devboard-specific)
     20          
     21           (from eief1-pcb-01):
     22           {WHITE, PURPLE, BLUE, CYAN, 
     23            GREEN, YELLOW, ORANGE, RED, 
     24            LCD_RED, LCD_GREEN, LCD_BLUE}
     25          
     26          - LedRateType:
     27            {LED_0HZ = 0, LED_0_5HZ = 1000, LED_1HZ = 500, LED_2HZ = 250, LED_4HZ = 125, LED_8HZ = 63,
     28             LED_PWM_0 = 0,   LED_PWM_5 = 1,   LED_PWM_10 = 2,  LED_PWM_15 = 3,  LED_PWM_20 = 4, 
     29             LED_PWM_25 = 5,  LED_PWM_30 = 6,  LED_PWM_35 = 7,  LED_PWM_40 = 8,  LED_PWM_45 = 9, 
     30             LED_PWM_50 = 10, LED_PWM_55 = 11, LED_PWM_60 = 12, LED_PWM_65 = 13, LED_PWM_70 = 14, 
     31             LED_PWM_75 = 15, LED_PWM_80 = 16, LED_PWM_85 = 17, LED_PWM_90 = 18, LED_PWM_95 = 19, 
     32             LED_PWM_100 = 20} 
     33          
     34          PUBLIC FUNCTIONS
     35          - void LedOn(LedNameType eLED_)
     36          - void LedOff(LedNameType eLED_)
     37          - void LedToggle(LedNameType eLED_)
     38          - void LedBlink(LedNameType eLED_, LedRateType eBlinkRate_)
     39          - void LedPWM(LedNameType eLED_, LedRateType ePwmRate_)
     40          
     41          PROTECTED FUNCTIONS
     42          - void LedInitialize(void)
     43          - void LedRunActiveState(void)
     44          
     45          DISCLAIMER: THIS CODE IS PROVIDED WITHOUT ANY WARRANTY OR GUARANTEES.  USERS MAY
     46          USE THIS CODE FOR DEVELOPMENT AND EXAMPLE PURPOSES ONLY.  ENGENUICS TECHNOLOGIES
     47          INCORPORATED IS NOT RESPONSIBLE FOR ANY ERRORS, OMISSIONS, OR DAMAGES THAT COULD
     48          RESULT FROM USING THIS FIRMWARE IN WHOLE OR IN PART.
     49          ***********************************************************************************************************************/
     50          
     51          #include "configuration.h"

                GPIOE_TASK0  = 0, GPIOE_TASK0  = 1, GPIOE_TASK0  = 2, GPIOE_TASK0  = 3, 
                                  ^
"D:\EiE\EiE Git\AntBleBeacon\application\typedefs.h",65  Error[Pe101]: 
          "GPIOE_TASK0" has already been declared in the current scope (at line
          65)

                GPIOE_TASK0  = 0, GPIOE_TASK0  = 1, GPIOE_TASK0  = 2, GPIOE_TASK0  = 3, 
                                                    ^
"D:\EiE\EiE Git\AntBleBeacon\application\typedefs.h",65  Error[Pe101]: 
          "GPIOE_TASK0" has already been declared in the current scope (at line
          65)

                GPIOE_TASK0  = 0, GPIOE_TASK0  = 1, GPIOE_TASK0  = 2, GPIOE_TASK0  = 3, 
                                                                      ^
"D:\EiE\EiE Git\AntBleBeacon\application\typedefs.h",65  Error[Pe101]: 
          "GPIOE_TASK0" has already been declared in the current scope (at line
          65)

  void LedOn(LedNumberType eLED_);
             ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",76  Error[Pe020]: identifier
          "LedNumberType" is undefined

  void LedOff(LedNumberType eLED_);
              ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",77  Error[Pe020]: identifier
          "LedNumberType" is undefined

  void LedToggle(LedNumberType eLED_);
                 ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",78  Error[Pe020]: identifier
          "LedNumberType" is undefined

  void LedPWM(LedNumberType eLED_, LedRateType ePwmRate_);
              ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",79  Error[Pe020]: identifier
          "LedNumberType" is undefined

  void LedBlink(LedNumberType eLED_, LedRateType ePwmRate_);
                ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.h",80  Error[Pe020]: identifier
          "LedNumberType" is undefined
     52          
     53          
     54          /***********************************************************************************************************************
     55          Global variable definitions with scope across entire project.
     56          All Global variable names shall start with "G_xxLed"
     57          ***********************************************************************************************************************/
     58          /*--------------------------------------------------------------------------------------------------------------------*/
     59          /* New variables (all shall start with G_xxLed*/
     60          
     61          
     62          /*--------------------------------------------------------------------------------------------------------------------*/
     63          /* External global variables defined in other files (must indicate which file they are defined in) */
     64          extern volatile u32 G_u32SystemTime1ms;                /*!< @brief From main.c */
     65          extern volatile u32 G_u32SystemTime1s;                 /*!< @brief From main.c */
     66          extern volatile u32 G_u32SystemFlags;                  /*!< @brief From main.c */
     67          
     68          extern const PinConfigurationType G_asBspLedConfigurations[U8_TOTAL_LEDS]; /*!< @brief from board-specific file */
                              ^
Error[Pe020]: identifier "PinConfigurationType" is undefined
     69          
     70          
     71          /***********************************************************************************************************************
     72          Global variable definitions with scope limited to this local application.
     73          Variable names shall start with "Led_" and be declared as static.
     74          ***********************************************************************************************************************/
     75          static fnCode_type Led_StateMachine;                   /*!< @brief The state machine function pointer */
     76          
     77          static LedControlType Led_asControl[U8_TOTAL_LEDS];    /*!< @brief Holds individual control parameters for LEDs */
     78          
     79          
     80          /* Control array for all LEDs in system initialized for LedInitialize().  Array values correspond to LedConfigType fields: 
     81               eMode         eRate      u16Count       eCurrentDuty     eActiveState     ePort      LedNumberType */
     82          static LedConfigType Leds_asLedArray[TOTAL_LEDS] = 
                        ^
Error[Pe020]: identifier "LedConfigType" is undefined
     83          {
     84           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* BLUE7       */
                                                                                 ^
Error[Pe020]: identifier "LED_ACTIVE_HIGH" is undefined
     85           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* GREEN7      */
     86           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* RED2        */
     87           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* RED3        */
     88           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* RED4        */
     89           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* RED5        */
     90           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* RED7        */
     91           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* RED0        */
     92           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* RED6        */
     93           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* RED1        */
     94           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* BLUE1       */
     95           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* BLUE0       */
     96           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* GREEN0      */
     97           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* GREEN1      */
     98           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* BLUE2       */
     99           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* GREEN2      */
    100           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* BLUE3       */
    101           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* GREEN3      */
    102           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* BLUE4       */
    103           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* GREEN4      */
    104           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* BLUE5       */
    105           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* GREEN5      */
    106           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* BLUE6       */
    107           {LED_NORMAL_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH}, /* GREEN6      */
    108          };   
    109           
    110          
    111          /***********************************************************************************************************************
    112          * Function Definitions
    113          ***********************************************************************************************************************/
    114          
    115          /*--------------------------------------------------------------------------------------------------------------------*/
    116          /* Public functions */
    117          /*--------------------------------------------------------------------------------------------------------------------*/
    118          
    119          /*----------------------------------------------------------------------------------------------------------------------
    120          Function: LedOn
    121          
    122          Description:
    123          Turn the specified LED on.  Automatically takes care of the active low vs. active
    124          high LEDs.  
    125          
    126          Requires:
    127            - eLED_ is a valid LED index
    128            - Definitions in Leds_asLedArray[eLED_] are correct
    129            - Supports port 0 GPIO only
    130          
    131          Promises:
    132            - Requested LED is turned on 
    133            - Requested LED is always set to LED_NORMAL_MODE mode
    134          */
    135          void LedOn(LedNumberType eLED_)
                            ^
Error[Pe020]: identifier "LedNumberType" is undefined
    136          {
    137          
    138            if(Leds_asLedArray[eLED_].eActiveState == LED_ACTIVE_HIGH)
    139            {
    140              NRF_GPIO->OUTSET = Led_au32BitPositions[eLED_];
                                        ^
Error[Pe020]: identifier "Led_au32BitPositions" is undefined
    141            }
    142            else
    143            {
    144              NRF_GPIO->OUTCLR = Led_au32BitPositions[eLED_];
                                        ^
Error[Pe020]: identifier "Led_au32BitPositions" is undefined
    145            }
    146            
    147            /* Always set the LED back to LED_NORMAL_MODE mode */
    148          	Leds_asLedArray[(u8)eLED_].eMode = LED_NORMAL_MODE;
    149          
    150          } /* end LedOn() */
    151          
    152          
    153          /*----------------------------------------------------------------------------------------------------------------------
    154          Function: LedOff
    155          
    156          Description:
    157          Turn the specified LED off.  Automatically takes care of the active low vs. active
    158          high LEDs.  
    159          
    160          Requires:
    161            - eLED_ is a valid LED index
    162            - Definitions in Leds_asLedArray[eLED_] are correct
    163          
    164          Promises:
    165            - Requested LED is turned off
    166            - Requested LED is always set to LED_NORMAL_MODE mode
    167          */
    168          void LedOff(LedNumberType eLED_)
                             ^
Error[Pe020]: identifier "LedNumberType" is undefined
    169          {
    170            if(Leds_asLedArray[eLED_].eActiveState == LED_ACTIVE_HIGH)
    171            {
    172              NRF_GPIO->OUTCLR = Led_au32BitPositions[eLED_];
                                        ^
Error[Pe020]: identifier "Led_au32BitPositions" is undefined
    173            }
    174            else
    175            {
    176              NRF_GPIO->OUTSET = Led_au32BitPositions[eLED_];
                                        ^
Error[Pe020]: identifier "Led_au32BitPositions" is undefined
    177            }
    178          
    179            /* Always set the LED back to LED_NORMAL_MODE mode */
    180          	Leds_asLedArray[(u8)eLED_].eMode = LED_NORMAL_MODE;
    181            
    182          } /* end LedOff() */
    183          
    184          
    185          /*----------------------------------------------------------------------------------------------------------------------
    186          Function: LedToggle
    187          
    188          Description:
    189          Toggle the specified LED.
    190          
    191          Requires:
    192            - eLED_ is a valid LED index
    193            - eLED_ *should* be in LED_NORMAL_MODE
    194          
    195          Promises:
    196            - Requested LED is toggled
    197          */
    198          void LedToggle(LedNumberType eLED_)
                                ^
Error[Pe020]: identifier "LedNumberType" is undefined
    199          {
    200            u32 u32Current_Leds;
    201            
    202            u32Current_Leds = NRF_GPIO->IN;
    203            u32Current_Leds ^= Led_au32BitPositions[eLED_];
                                      ^
Error[Pe020]: identifier "Led_au32BitPositions" is undefined
    204            NRF_GPIO->OUT = u32Current_Leds;
    205                                                      
    206          } /* end LedToggle() */
    207          
    208          
    209          /*----------------------------------------------------------------------------------------------------------------------
    210          Function: LedPWM
    211          
    212          Description:
    213          Sets an LED to PWM mode
    214          
    215          Requires:
    216            - eLED_ is a valid LED index
    217            - ePwmRate_ is an allowed duty cycle:
    218              LED_PWM_0, LED_PWM_5, LED_PWM_10, ..., LED_PWM_95, LED_PWM_100
    219          
    220          Promises:
    221            - Requested LED is set to PWM mode at the duty cycle specified
    222          */
    223          void LedPWM(LedNumberType eLED_, LedRateType ePwmRate_)
                             ^
Error[Pe020]: identifier "LedNumberType" is undefined
    224          {
    225          	Leds_asLedArray[(u8)eLED_].eMode = LED_PWM_MODE;
    226          	Leds_asLedArray[(u8)eLED_].eRate = ePwmRate_;
    227          	Leds_asLedArray[(u8)eLED_].u16Count = (u16)ePwmRate_;
    228            Leds_asLedArray[(u8)eLED_].eCurrentDuty = LED_PWM_DUTY_HIGH;
    229          
    230          } /* end LedPWM() */
    231          
    232          
    233          /*----------------------------------------------------------------------------------------------------------------------
    234          Function: LedBlink
    235          
    236          Description:
    237          Sets an LED to BLINK mode.
    238          
    239          Requires:
    240            - eLED_ is a valid LED index
    241            - eBlinkRate_ is an allowed frequency:
    242              LED_0_5HZ, LED_1HZ, LED_2HZ, LED_4HZ, LED_8HZ
    243          
    244          Promises:
    245            - Requested LED is set to BLINK mode at the rate specified
    246          */
    247          void LedBlink(LedNumberType eLED_, LedRateType eBlinkRate_)
                               ^
Error[Pe020]: identifier "LedNumberType" is undefined
    248          {
    249          	Leds_asLedArray[(u8)eLED_].eMode = LED_BLINK_MODE;
    250          	Leds_asLedArray[(u8)eLED_].eRate = eBlinkRate_;
    251          	Leds_asLedArray[(u8)eLED_].u16Count = eBlinkRate_;
    252          
    253          } /* end LedBlink() */
    254          
    255          
    256          /*--------------------------------------------------------------------------------------------------------------------*/
    257          /* Protected functions */
    258          /*--------------------------------------------------------------------------------------------------------------------*/
    259          
    260          /*----------------------------------------------------------------------------------------------------------------------
    261          Function: LedInitialize
    262          
    263          Description:
    264          Initialization of LED system paramters and visual LED check.
    265          
    266          Requires:
    267            - G_u32SystemTime1ms ticking
    268            - All LEDs already initialized to LED_NORMAL_MODE mode ON
    269          
    270          Promises:
    271            - All LEDs in LED_NORMAL_MODE mode with OFF
    272          */
    273          void LedInitialize(void)
    274          {
    275            u32 u32Timer;
    276            LedNumberType aeLedSequence[] = {RED0, RED1, RED2, RED3, RED4, RED5, RED6, RED7,
                   ^
Error[Pe020]: identifier "LedNumberType" is undefined
    277                                             GREEN0, GREEN1, GREEN2, GREEN3, GREEN4, GREEN5, GREEN6, GREEN7,
                                                    ^
Error[Pe020]: identifier "GREEN0" is undefined

                                     GREEN0, GREEN1, GREEN2, GREEN3, GREEN4, GREEN5, GREEN6, GREEN7,
                                             ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",277  Error[Pe020]: identifier
          "GREEN1" is undefined

                                     GREEN0, GREEN1, GREEN2, GREEN3, GREEN4, GREEN5, GREEN6, GREEN7,
                                                     ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",277  Error[Pe020]: identifier
          "GREEN2" is undefined

                                     GREEN0, GREEN1, GREEN2, GREEN3, GREEN4, GREEN5, GREEN6, GREEN7,
                                                             ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",277  Error[Pe020]: identifier
          "GREEN3" is undefined

                                     GREEN0, GREEN1, GREEN2, GREEN3, GREEN4, GREEN5, GREEN6, GREEN7,
                                                                     ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",277  Error[Pe020]: identifier
          "GREEN4" is undefined

                                     GREEN0, GREEN1, GREEN2, GREEN3, GREEN4, GREEN5, GREEN6, GREEN7,
                                                                             ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",277  Error[Pe020]: identifier
          "GREEN5" is undefined

                                     GREEN0, GREEN1, GREEN2, GREEN3, GREEN4, GREEN5, GREEN6, GREEN7,
                                                                                     ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",277  Error[Pe020]: identifier
          "GREEN6" is undefined

                                     GREEN0, GREEN1, GREEN2, GREEN3, GREEN4, GREEN5, GREEN6, GREEN7,
                                                                                             ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",277  Error[Pe020]: identifier
          "GREEN7" is undefined
    278                                             BLUE0, BLUE1, BLUE2, BLUE3, BLUE4, BLUE5, BLUE6, BLUE7};
                                                    ^
Error[Pe020]: identifier "BLUE0" is undefined

                                     BLUE0, BLUE1, BLUE2, BLUE3, BLUE4, BLUE5, BLUE6, BLUE7};
                                            ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",278  Error[Pe020]: identifier
          "BLUE1" is undefined

                                     BLUE0, BLUE1, BLUE2, BLUE3, BLUE4, BLUE5, BLUE6, BLUE7};
                                                   ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",278  Error[Pe020]: identifier
          "BLUE2" is undefined

                                     BLUE0, BLUE1, BLUE2, BLUE3, BLUE4, BLUE5, BLUE6, BLUE7};
                                                          ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",278  Error[Pe020]: identifier
          "BLUE3" is undefined

                                     BLUE0, BLUE1, BLUE2, BLUE3, BLUE4, BLUE5, BLUE6, BLUE7};
                                                                 ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",278  Error[Pe020]: identifier
          "BLUE4" is undefined

                                     BLUE0, BLUE1, BLUE2, BLUE3, BLUE4, BLUE5, BLUE6, BLUE7};
                                                                        ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",278  Error[Pe020]: identifier
          "BLUE5" is undefined

                                     BLUE0, BLUE1, BLUE2, BLUE3, BLUE4, BLUE5, BLUE6, BLUE7};
                                                                               ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",278  Error[Pe020]: identifier
          "BLUE6" is undefined

                                     BLUE0, BLUE1, BLUE2, BLUE3, BLUE4, BLUE5, BLUE6, BLUE7};
                                                                                      ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",278  Error[Pe020]: identifier
          "BLUE7" is undefined
    279          
    280            /* Static Display of all colors */
    281            LedOn(RED0);
    282            LedOn(GREEN0);
    283            LedOn(BLUE0);
    284            
    285            LedOn(RED1);
    286            LedOn(BLUE1);
    287            
    288            LedOn(BLUE2);
    289          
    290            LedOn(GREEN3);
    291            LedOn(BLUE3);
    292          
    293            LedOn(GREEN4);
    294            
    295            LedOn(GREEN5);
    296            LedOn(RED5);
    297            
    298            LedOn(RED6);
    299          
    300            LedOn(RED7);
    301            //LedOn(GREEN7);
    302            //LedOn(BLUE7);
    303            
    304            while(1);
    305            /* end of static display */
    306          
    307            
    308            while(1)
                   ^
Warning[Pe128]: loop is not reachable
    309          #if 0
    310            {
    311              /* Sequentially light up a specific color of LEDs */
    312              for(u8 k = 0; k < 3; k++)
    313              {
    314                for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    315                {
    316                  LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * k)]);
    317                  for(u32 j = 0; j < 200000; j++);
    318                }
    319                
    320                /* Pause for show */
    321                for(u32 i = 0; i < 500000; i++);
    322          
    323                /* Turn off the current LEDs */
    324                for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    325                {
    326                  LedOff(aeLedSequence[i + (8 * k)]);
    327                }
    328              }
    329          #endif
    330          
    331          #if 0 /* one-way sequence */
    332            {
    333              /* Red */
    334              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    335              {
    336                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 0)]);
    337                for(u32 j = 0; j < STEP_TIME; j++);
    338              }    
    339          
    340              /* Pause for show */
    341              for(u32 i = 0; i < PAUSE_TIME; i++);
    342          
    343              /* All off */
    344              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    345              {
    346                LedOff(aeLedSequence[i + (8 * 0)]);
    347                LedOff(aeLedSequence[i + (8 * 1)]);
    348                LedOff(aeLedSequence[i + (8 * 2)]);
    349              }
    350          
    351              /* Yellow */
    352              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    353              {
    354                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 0)]);
    355                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 1)]);
    356                for(u32 j = 0; j < STEP_TIME; j++);
    357              }    
    358          
    359              /* Pause for show */
    360              for(u32 i = 0; i < PAUSE_TIME; i++);
    361          
    362              /* All off */
    363              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    364              {
    365                LedOff(aeLedSequence[i + (8 * 0)]);
    366                LedOff(aeLedSequence[i + (8 * 1)]);
    367                LedOff(aeLedSequence[i + (8 * 2)]);
    368              }
    369          
    370              /* Green */
    371              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    372              {
    373                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 1)]);
    374                for(u32 j = 0; j < STEP_TIME; j++);
    375              }    
    376          
    377              /* Pause for show */
    378              for(u32 i = 0; i < PAUSE_TIME; i++);
    379          
    380              /* All off */
    381              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    382              {
    383                LedOff(aeLedSequence[i + (8 * 0)]);
    384                LedOff(aeLedSequence[i + (8 * 1)]);
    385                LedOff(aeLedSequence[i + (8 * 2)]);
    386              }
    387          
    388              /* Cyan */
    389              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    390              {
    391                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 1)]);
    392                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 2)]);
    393                for(u32 j = 0; j < STEP_TIME; j++);
    394              }    
    395          
    396              /* Pause for show */
    397              for(u32 i = 0; i < PAUSE_TIME; i++);
    398          
    399              /* All off */
    400              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    401              {
    402                LedOff(aeLedSequence[i + (8 * 0)]);
    403                LedOff(aeLedSequence[i + (8 * 1)]);
    404                LedOff(aeLedSequence[i + (8 * 2)]);
    405              }
    406          
    407              /* Blue */
    408              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    409              {
    410                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 2)]);
    411                for(u32 j = 0; j < STEP_TIME; j++);
    412              }    
    413          
    414              /* Pause for show */
    415              for(u32 i = 0; i < PAUSE_TIME; i++);
    416          
    417              /* All off */
    418              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    419              {
    420                LedOff(aeLedSequence[i + (8 * 0)]);
    421                LedOff(aeLedSequence[i + (8 * 1)]);
    422                LedOff(aeLedSequence[i + (8 * 2)]);
    423              }
    424          
    425              
    426              /* Purple */
    427              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    428              {
    429                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 0)]);
    430                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 2)]);
    431                for(u32 j = 0; j < STEP_TIME; j++);
    432              }    
    433          
    434              /* Pause for show */
    435              for(u32 i = 0; i < PAUSE_TIME; i++);
    436          
    437              /* All off */
    438              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    439              {
    440                LedOff(aeLedSequence[i + (8 * 0)]);
    441                LedOff(aeLedSequence[i + (8 * 1)]);
    442                LedOff(aeLedSequence[i + (8 * 2)]);
    443              }
    444          
    445              /* White */
    446              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    447              {
    448                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 0)]);
    449                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 1)]);
    450                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 2)]);
    451                for(u32 j = 0; j < STEP_TIME; j++);
    452              }    
    453          
    454              /* Pause for show */
    455              for(u32 i = 0; i < PAUSE_TIME; i++);
    456          
    457              /* All off */
    458              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    459              {
    460                LedOff(aeLedSequence[i + (8 * 0)]);
    461                LedOff(aeLedSequence[i + (8 * 1)]);
    462                LedOff(aeLedSequence[i + (8 * 2)]);
    463              }
    464          
    465            }
    466          #endif
    467            
    468            
    469            {
    470              /* Red */
    471              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    472              {
    473                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 0)]);
    474                for(u32 j = 0; j < STEP_TIME; j++);
    475              }    
    476          
    477              for(u32 j = 0; j < STEP_TIME; j++);
    478          
    479              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    480              {
    481                LedOff(aeLedSequence[7 - i + (NUM_LEDS_PER_COLOR * 0)]);
    482                for(u32 j = 0; j < STEP_TIME; j++);
    483              }    
    484          
    485              /* Yellow */
    486              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    487              {
    488                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 0)]);
    489                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 1)]);
    490                for(u32 j = 0; j < STEP_TIME; j++);
    491              }    
    492          
    493              for(u32 j = 0; j < STEP_TIME; j++);
    494          
    495              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    496              {
    497                LedOff(aeLedSequence[7 - i + (NUM_LEDS_PER_COLOR * 0)]);
    498                LedOff(aeLedSequence[7 - i + (NUM_LEDS_PER_COLOR * 1)]);
    499                for(u32 j = 0; j < STEP_TIME; j++);
    500              }    
    501          
    502              /* Green */
    503              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    504              {
    505                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 1)]);
    506                for(u32 j = 0; j < STEP_TIME; j++);
    507              }    
    508          
    509              for(u32 j = 0; j < STEP_TIME; j++);
    510          
    511              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    512              {
    513                LedOff(aeLedSequence[7 - i + (NUM_LEDS_PER_COLOR * 1)]);
    514                for(u32 j = 0; j < STEP_TIME; j++);
    515              }    
    516          
    517              /* Cyan */
    518              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    519              {
    520                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 1)]);
    521                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 2)]);
    522                for(u32 j = 0; j < STEP_TIME; j++);
    523              }    
    524          
    525              for(u32 j = 0; j < STEP_TIME; j++);
    526          
    527              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    528              {
    529                LedOff(aeLedSequence[7 - i + (NUM_LEDS_PER_COLOR * 1)]);
    530                LedOff(aeLedSequence[7 - i + (NUM_LEDS_PER_COLOR * 2)]);
    531                for(u32 j = 0; j < STEP_TIME; j++);
    532              }    
    533          
    534              /* Blue */
    535              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    536              {
    537                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 2)]);
    538                for(u32 j = 0; j < STEP_TIME; j++);
    539              }    
    540          
    541              for(u32 j = 0; j < STEP_TIME; j++);
    542          
    543             for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    544              {
    545                LedOff(aeLedSequence[7 - i + (NUM_LEDS_PER_COLOR * 2)]);
    546                for(u32 j = 0; j < STEP_TIME; j++);
    547              }    
    548          
    549              /* Purple */
    550              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    551              {
    552                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 0)]);
    553                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 2)]);
    554                for(u32 j = 0; j < STEP_TIME; j++);
    555              }    
    556          
    557              for(u32 j = 0; j < STEP_TIME; j++);
    558          
    559              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    560              {
    561                LedOff(aeLedSequence[7 - i + (NUM_LEDS_PER_COLOR * 0)]);
    562                LedOff(aeLedSequence[7 - i + (NUM_LEDS_PER_COLOR * 2)]);
    563                for(u32 j = 0; j < STEP_TIME; j++);
    564              }    
    565          
    566              /* While */
    567              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    568              {
    569                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 0)]);
    570                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 1)]);
    571                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 2)]);
    572                for(u32 j = 0; j < STEP_TIME; j++);
    573              }    
    574          
    575              for(u32 j = 0; j < STEP_TIME; j++);
    576          
    577              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    578              {
    579                LedOff(aeLedSequence[7 - i + (NUM_LEDS_PER_COLOR * 0)]);
    580                LedOff(aeLedSequence[7 - i + (NUM_LEDS_PER_COLOR * 1)]);
    581                LedOff(aeLedSequence[7 - i + (NUM_LEDS_PER_COLOR * 2)]);
    582                for(u32 j = 0; j < STEP_TIME; j++);
    583              }    
    584          
    585          
    586          
    587            }
    588          #if 0
    589            {
    590              /* Red */
    591              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    592              {
    593                LedOn(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 0)]);
    594                for(u32 j = 0; j < STEP_TIME; j++);
    595                LedOff(aeLedSequence[i + (NUM_LEDS_PER_COLOR * 0)]);
    596              }    
    597          
    598              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
    599              {
    600                LedOn(aeLedSequence[(7 - i) + (NUM_LEDS_PER_COLOR * 0)]);
    601                for(u32 j = 0; j < STEP_TIME; j++);
    602                LedOff(aeLedSequence[(7 - i) + (NUM_LEDS_PER_COLOR * 0)]);
    603              }    
    604          
    605            }
    606          #endif
    607            
    608            /* Finish with all white */
    609              for(u8 i = 0; i < NUM_LEDS_PER_COLOR; i++)
                     ^
Warning[Pe128]: loop is not reachable

    u32 u32Timer;
        ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",275  Warning[Pe177]: variable
          "u32Timer" was declared but never referenced
    610              {
    611                LedOn(aeLedSequence[i]);
    612                LedOn(aeLedSequence[i + NUM_LEDS_PER_COLOR]);
    613                LedOn(aeLedSequence[i + (2 * NUM_LEDS_PER_COLOR)]);
    614                for(u32 j = 0; j < 100000; j++);
    615              }
    616          
    617              /* Pause for show */
    618            for(u32 i = 0; i < 2000000; i++);
    619          
    620          #if 0
    621            /* Turn all LEDs on full, then fade them out over a few seconds */
    622            for(u8 i = 20; i > 0; i--)
    623            {
    624              
    625              /* Spend 40ms in each level of intensity */
    626              for(u16 j = 40; j > 0; j--)
    627              {
    628                u32Timer = G_u32SystemTime1ms;
    629                while( !IsTimeUp(&u32Timer, 1) );
    630                LedUpdate();
    631              }
    632              /* Pause for a bit on the first iteration to show the LEDs on for little while */
    633              if(i == 20)
    634              {
    635                while( !IsTimeUp(&u32Timer, 1500) );
    636              }
    637              
    638              /* Set the LED intensity for the next iteration */
    639              for(u8 j = 0; j < TOTAL_LEDS; j++)
    640              {
    641                Leds_asLedArray[j].eRate = (LedRateType)(i - 1);
    642              }
    643            }
    644          
    645            /* Final update to set last state, hold for a short period */
    646            LedUpdate();
    647            while( !IsTimeUp(&u32Timer, 200) );
    648          #endif
    649            
    650          } /* end LedInitialize() */
    651          
    652          
    653          /*!----------------------------------------------------------------------------------------------------------------------
    654          @fn void LedRunActiveState(void)
    655          
    656          @brief Selects and runs one iteration of the current state in the state machine.
    657          
    658          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    659          may take 1ms / n to execute.
    660          
    661          Requires:
    662          - State machine function pointer points at current state
    663          
    664          Promises:
    665          - Calls the function to pointed by the state machine function pointer
    666          
    667          */
    668          void LedRunActiveState(void)
                      ^
Error[Pa045]: function "LedRunActiveState" has no prototype
    669          {
    670            Led_StateMachine();
    671          
    672          } /* end LedRunActiveState */
    673          
    674          
    675          /*--------------------------------------------------------------------------------------------------------------------*/
    676          /* Private functions */
    677          /*--------------------------------------------------------------------------------------------------------------------*/
    678          
    679          /*----------------------------------------------------------------------------------------------------------------------
    680          Function: LedUpdate
    681          
    682          Description:
    683          Update all LEDs for the current cycle.
    684          
    685          Requires:
    686           - G_u32SystemTime1ms is counting
    687          
    688          Promises:
    689             - All LEDs updated based on their counters
    690          */
    691          void LedUpdate(void)
    692          {
    693          	/* Loop through each LED */
    694            for(u8 i = 0; i < TOTAL_LEDS; i++)
    695            {
    696              /* Check if LED is PWMing */
    697              if(Leds_asLedArray[(LedNumberType)i].eMode == LED_PWM_MODE)
                                         ^
Error[Pe020]: identifier "LedNumberType" is undefined

      if(Leds_asLedArray[(LedNumberType)i].eMode == LED_PWM_MODE)
                                        ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",697  Error[Pe017]: expected a
          "]"
    698              {
    699                /* Handle special case of 0% duty cycle */
    700                if( Leds_asLedArray[i].eRate == LED_PWM_0 )
    701                {
    702                  LedOff( (LedNumberType)i );
                                                ^
Error[Pe018]: expected a ")"
    703                }
    704                
    705                /* Handle special case of 100% duty cycle */
    706                else if( Leds_asLedArray[i].eRate == LED_PWM_100 )
    707                {
    708                  LedOn( (LedNumberType)i );
                                               ^
Error[Pe018]: expected a ")"
    709                }
    710            
    711                /* Otherwise, regular PWM: decrement counter; toggle and reload if counter reaches 0 */
    712                else
    713                {
    714                  if(--Leds_asLedArray[(LedNumberType)i].u16Count == 0)
                                                             ^
Error[Pe017]: expected a "]"
    715                  {
    716                    if(Leds_asLedArray[(LedNumberType)i].eCurrentDuty == LED_PWM_DUTY_HIGH)
                                                             ^
Error[Pe017]: expected a "]"
    717                    {
    718                      /* Turn the LED off and update the counters for the next cycle */
    719                      LedOff( (LedNumberType)i );
                                                    ^
Error[Pe018]: expected a ")"
    720                      Leds_asLedArray[(LedNumberType)i].u16Count = LED_PWM_PERIOD - Leds_asLedArray[(LedNumberType)i].eRate;
                                                            ^
Error[Pe017]: expected a "]"

              Leds_asLedArray[(LedNumberType)i].u16Count = LED_PWM_PERIOD - Leds_asLedArray[(LedNumberType)i].eRate;
                                                           ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",720  Error[Pe020]: identifier
          "LED_PWM_PERIOD" is undefined

              Leds_asLedArray[(LedNumberType)i].u16Count = LED_PWM_PERIOD - Leds_asLedArray[(LedNumberType)i].eRate;
                                                                                                           ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",720  Error[Pe017]: expected a
          "]"
    721                      Leds_asLedArray[(LedNumberType)i].eCurrentDuty = LED_PWM_DUTY_LOW;
                                                            ^
Error[Pe017]: expected a "]"
    722                    }
    723                    else
    724                    {
    725                      /* Turn the LED on and update the counters for the next cycle */
    726                      LedOn( (LedNumberType)i );
                                                   ^
Error[Pe018]: expected a ")"
    727                      Leds_asLedArray[i].u16Count = Leds_asLedArray[i].eRate;
    728                      Leds_asLedArray[i].eCurrentDuty = LED_PWM_DUTY_HIGH;
    729                    }
    730                  }
    731                }
    732          
    733                /* Set the LED back to PWM mode since LedOff and LedOn set it to normal mode */
    734               	Leds_asLedArray[(LedNumberType)i].eMode = LED_PWM_MODE;
                      	                               ^
Error[Pe017]: expected a "]"
    735                
    736              } /* end if PWM mode */
    737              
    738              /* LED is in LED_BLINK_MODE mode */
    739              else if(Leds_asLedArray[(LedNumberType)i].eMode == LED_BLINK_MODE)
                                                            ^
Error[Pe017]: expected a "]"
    740              {
    741                /* Decrement counter; toggle and reload if counter reaches 0 */
    742                if( --Leds_asLedArray[(LedNumberType)i].u16Count == 0)
                                                            ^
Error[Pe017]: expected a "]"
    743                {
    744                  LedToggle( (LedNumberType)i );
                                                   ^
Error[Pe018]: expected a ")"
    745                  Leds_asLedArray[(LedNumberType)i].u16Count = Leds_asLedArray[(LedNumberType)i].eRate;
                                                        ^
Error[Pe017]: expected a "]"

          Leds_asLedArray[(LedNumberType)i].u16Count = Leds_asLedArray[(LedNumberType)i].eRate;
                                                                                      ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",745  Error[Pe017]: expected a
          "]"
    746                }
    747              }
    748            } /* end for */
    749          } /* end LedUpdate() */
    750          
    751          
    752          /***********************************************************************************************************************
    753          State Machine Declarations
    754          ***********************************************************************************************************************/
    755          
    756          /*!-------------------------------------------------------------------------------------------------------------------
    757          @fn static void LedSM_Idle(void)
    758          
    759          @brief Run through all the LEDs to check for blinking updates.
    760          */
    761          static void LedSM_Idle(void)
    762          {
    763            u32 u32Current;
    764            
    765          	/* Loop through each LED to check for blinkers */
    766            for(u8 i = 0; i < U8_TOTAL_LEDS; i++)
    767            {
    768              /* Check if LED is in LED_BLINK_MODE */
    769              if(Led_asControl[(LedNameType)i].eMode == LED_BLINK_MODE)
    770              {
    771                /* Decrement counter and check for 0 */
    772                Led_asControl[(LedNameType)i].u16Count--;
    773                if( Led_asControl[(LedNameType)i].u16Count == 0)
    774                {
    775                  /* Toggle based on current state */
    776                  if(NRF_GPIO->IN & Led_asControl[(LedNameType)i].u32BitPosition)
                                                                         ^
Error[Pe136]: struct "<unnamed>#176" has no field "u32BitPosition"

    u32 u32Current;
        ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",763  Warning[Pe177]: variable
          "u32Current" was declared but never referenced

  static void LedSM_Idle(void)
              ^
"D:\EiE\EiE Git\AntBleBeacon\bsp\leds_nrf51.c",761  Warning[Pe177]: function
          "LedSM_Idle" was declared but never referenced
    777                  {
    778                    NRF_GPIO->OUTCLR = G_asBspLedConfigurations[i].u32BitPosition;
    779                  }
    780                  else
    781                  {
    782                    NRF_GPIO->OUTSET = G_asBspLedConfigurations[i].u32BitPosition;
    783                  }
    784                  
    785                  /* Reload the blink counter value */
    786                  Led_asControl[(LedNameType)i].u16Count = Led_asControl[(LedNameType)i].eRate;
    787                }
    788              } /* end LED_BLINK_MODE */
    789              
    790              /* Check if LED is in LED_PWM_MODE */
    791              if(Led_asControl[(LedNameType)i].eMode == LED_PWM_MODE)
    792              {
    793                /* Handle special case of 0% duty cycle */
    794                if( Led_asControl[i].eRate == LED_PWM_0 )
    795                {
    796                  LedOff( (LedNameType)i );
    797                }
    798                
    799                /* Handle special case of 100% duty cycle */
    800                else if( Led_asControl[i].eRate == LED_PWM_100 )
    801                {
    802                  LedOn( (LedNameType)i );
    803                }
    804            
    805                /* Otherwise, regular PWM: decrement counter; toggle and reload if counter reaches 0 */
    806                else
    807                {
    808                  Led_asControl[(LedNameType)i].u16Count--;
    809                  if(Led_asControl[(LedNameType)i].u16Count == 0)
    810                  {
    811                    if(Led_asControl[(LedNameType)i].eCurrentDuty == LED_PWM_DUTY_HIGH)
    812                    {
    813                      /* Turn the LED off and update the counters for the next cycle */
    814                      LedOff( (LedNameType)i );
    815                      Led_asControl[(LedNameType)i].u16Count = LED_PWM_100 - Led_asControl[(LedNameType)i].eRate;
    816                      Led_asControl[(LedNameType)i].eCurrentDuty = LED_PWM_DUTY_LOW;
    817                    }
    818                    else
    819                    {
    820                      /* Turn the LED on and update the counters for the next cycle */
    821                      LedOn( (LedNameType)i );
    822                      Led_asControl[i].u16Count = Led_asControl[i].eRate;
    823                      Led_asControl[i].eCurrentDuty = LED_PWM_DUTY_HIGH;
    824                    }
    825                  }
    826                }
    827          
    828                /* Set the LED back to PWM mode since LedOff and LedOn set it to normal mode */
    829               	Led_asControl[(LedNameType)i].eMode = LED_PWM_MODE;
    830                
    831              } /* end LED_PWM_MODE */
    832              
    833            } /* end for(u8 i = 0; i < U8_TOTAL_LEDS; i++) */
    834             
    835          } /* end LedSM_Idle() */
    836          
    837          
    838          
    839          
    840          /*--------------------------------------------------------------------------------------------------------------------*/
    841          /* End of File */
    842          /*--------------------------------------------------------------------------------------------------------------------*/
    843          
    844          

Errors: 58
Warnings: 5
