###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        29/Jun/2018  10:17:52
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\EiE\EiE Git\AntBleBeacon\bsp\buttons_nrf51_standard.c
#    Command line =  
#        "D:\EiE\EiE Git\AntBleBeacon\bsp\buttons_nrf51_standard.c" -D NRF51
#        -lC "D:\EiE\EiE Git\AntBleBeacon\iar_7_20_1\Debug\List\" -o
#        "D:\EiE\EiE Git\AntBleBeacon\iar_7_20_1\Debug\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0 -e --fpu=None
#        --dlib_config "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\INC\c\DLib_Config_Normal.h" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_7_20_1\..\bsp\" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_7_20_1\..\application\" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_7_20_1\..\nordic_sdk6_1_0\" -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_7_20_1\..\nordic_sdk6_1_0\Include\" -I
#        "D:\EiE\EiE
#        Git\AntBleBeacon\iar_7_20_1\..\nordic_sdk6_1_0\Include\s310\" -I
#        "D:\EiE\EiE
#        Git\AntBleBeacon\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\" -I
#        "D:\EiE\EiE
#        Git\AntBleBeacon\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\ble_services\"
#        -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\device_manager\"
#        -I "D:\EiE\EiE
#        Git\AntBleBeacon\iar_7_20_1\..\nordic_sdk6_1_0\Include\app_common\"
#        -On --require_prototypes -I "C:\Program Files\IAR
#        Systems\EWARM_7_20_1\arm\CMSIS\Include\"
#    List file    =  
#        D:\EiE\EiE
#        Git\AntBleBeacon\iar_7_20_1\Debug\List\buttons_nrf51_standard.lst
#    Object file  =  
#        D:\EiE\EiE
#        Git\AntBleBeacon\iar_7_20_1\Debug\Obj\buttons_nrf51_standard.o
#
###############################################################################

D:\EiE\EiE Git\AntBleBeacon\bsp\buttons_nrf51_standard.c
      1          /*!**********************************************************************************************************************
      2          @file buttons_nrf51_standard.c                                                                
      3          @brief Button functions and state machine.  
      4          
      5          The application handles all debouncing and button press / hold detection for buttons
      6          used on development boards with the nRF51 processor.  All buttons use dedicated
      7          hardwware lines (active high or active low), with interrupts to trigger the 
      8          start and end of the action.
      9          
     10          ------------------------------------------------------------------------------------------------------------------------
     11          GLOBALS
     12          - NONE
     13          
     14          CONSTANTS
     15          - U32_DEBOUNCE_TIME
     16          
     17          TYPES
     18          - enum ButtonStateType
     19          - struct ButtonStatusType
     20          
     21          PUBLIC FUNCTIONS
     22          - bool IsButtonPressed(ButtonNameType eButton_)
     23          - bool WasButtonPressed(ButtonNameType eButton_)
     24          - void ButtonAcknowledge(ButtonNameType eButton_)
     25          - bool IsButtonHeld(ButtonNameType eButton_, u32 u32ButtonHeldTime_)
     26          
     27          PROTECTED FUNCTIONS
     28          - void ButtonInitialize(void)
     29          - void ButtonRunActiveState(void)
     30          - void ButtonStartDebounce(u32 u32BitPosition_, PortOffsetType ePort_)
     31          
     32          
     33          ***********************************************************************************************************************/
     34          
     35          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpiote_event_config(uint32_t, uint32_t, enum <unnamed>)
   \                     nrf_gpiote_event_config: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x020B             LSLS     R3,R1,#+8
   \   00000004   0xB2D2             UXTB     R2,R2
   \   00000006   0x0414             LSLS     R4,R2,#+16
   \   00000008   0x431C             ORRS     R4,R4,R3
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x4323             ORRS     R3,R3,R4
   \   0000000E   0x....             LDR      R4,??DataTable8  ;; 0x40006510
   \   00000010   0x2504             MOVS     R5,#+4
   \   00000012   0x4345             MULS     R5,R0,R5
   \   00000014   0x5163             STR      R3,[R4, R5]
   \   00000016   0xBF00             Nop      
   \   00000018   0xBF00             Nop      
   \   0000001A   0xBF00             Nop      
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x....             LDR      R4,??DataTable9  ;; 0x40006100
   \   00000020   0x2504             MOVS     R5,#+4
   \   00000022   0x4345             MULS     R5,R0,R5
   \   00000024   0x5163             STR      R3,[R4, R5]
   \   00000026   0xBC30             POP      {R4,R5}
   \   00000028   0x4770             BX       LR               ;; return
     36          
     37          /***********************************************************************************************************************
     38          Global variable definitions with scope across entire project.
     39          All Global variable names shall start with "G_<type>Button"
     40          ***********************************************************************************************************************/
     41          /* New variables */
     42          
     43          
     44          /*--------------------------------------------------------------------------------------------------------------------*/
     45          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     46          extern volatile u32 G_u32SystemTime1ms;                /*!< @brief From main.c */
     47          extern volatile u32 G_u32SystemTime1s;                 /*!< @brief From main.c */
     48          extern volatile u32 G_u32SystemFlags;                  /*!< @brief From main.c */
     49          
     50          extern const Nrf51PinConfigurationType G_asBspButtonConfigurations[U8_TOTAL_BUTTONS]; /*!< @brief from board-specific file */
     51          
     52          
     53          /***********************************************************************************************************************
     54          Global variable definitions with scope limited to this local application.
     55          Variable names shall start with "Button_<type>" and be declared as static.
     56          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     57          static fnCode_type Button_pfnStateMachine;                  /* The Button application state machine function pointer */
   \                     Button_pfnStateMachine:
   \   00000000                      DS8 4
     58          

   \                                 In section .bss, align 4
     59          static ButtonStatusType Button_asStatus[U8_TOTAL_BUTTONS];  /*!< @brief Individual status parameters for buttons */
   \                     Button_asStatus:
   \   00000000                      DS8 12
     60          
     61          #if 0
     62          static ButtonStateType Button_aeCurrentState[TOTAL_BUTTONS];/* Current pressed state of button */
     63          static ButtonStateType Button_aeNewState[TOTAL_BUTTONS];    /* New (pending) pressed state of button */
     64          static u32 Button_au32HoldTimeStart[TOTAL_BUTTONS];         /* System 1ms time when a button press started */
     65          static bool Button_abNewPress[TOTAL_BUTTONS];               /* Flags to indicate a button was pressed */    
     66          static u8 Button_u8ActiveCol;                               /* Current Active Button Column */                                                                                    
     67          #endif
     68          
     69          
     70          /***********************************************************************************************************************
     71          Function Definitions
     72          ***********************************************************************************************************************/
     73          
     74          /*------------------------------------------------------------------------------------------------------------------*/
     75          /*! @publicsection */                                                                                            
     76          /*--------------------------------------------------------------------------------------------------------------------*/
     77          
     78          /*!----------------------------------------------------------------------------------------------------------------------
     79          @fn bool IsButtonPressed(ButtonNameType eButton_)
     80          
     81          @brief Determine if a particular button is currently pressed at the moment in time when 
     82          the function is called.
     83          
     84          The button must still be pressed at the time of this inquiry for the function
     85          to return TRUE.
     86          
     87          Requires:
     88          - Button_asStatus[eButton_] is a valid index
     89          
     90          @param eButton_ is a valid button 
     91           
     92          Promises:
     93          - Returns TRUE if Button_asStatus[eButton_].eCurrentState is PRESSED 
     94          - Otherwise returns FALSE
     95          
     96          */

   \                                 In section .text, align 2, keep-with-next
     97          bool IsButtonPressed(ButtonNameType eButton_)
     98          {
   \                     IsButtonPressed: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
     99            if( Button_asStatus[(u8)eButton_].eCurrentState == PRESSED)
   \   00000004   0x....             LDR      R0,??DataTable9_1
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x220C             MOVS     R2,#+12
   \   0000000A   0x434A             MULS     R2,R1,R2
   \   0000000C   0x1880             ADDS     R0,R0,R2
   \   0000000E   0x7880             LDRB     R0,[R0, #+2]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD101             BNE      ??IsButtonPressed_0
    100            {
    101              return(TRUE);
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B        ??IsButtonPressed_1
    102            }
    103            else
    104            {
    105              return(FALSE);
   \                     ??IsButtonPressed_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??IsButtonPressed_1: (+1)
   \   0000001A   0xBD00             POP      {PC}             ;; return
    106            }
    107          
    108          } /* end IsButtonPressed() */
    109          
    110          
    111          /*!----------------------------------------------------------------------------------------------------------------------
    112          @fn bool WasButtonPressed(ButtonNameType eButton_)
    113          
    114          @brief Determines if a particular button was pressed since last time it was checked. 
    115          
    116          This is effectively a latching function so that button presses are
    117          not missed and are potentially available to multiple tasks.
    118          
    119          The button may or may not still be pressed when this inquiry is made.  Mulitple
    120          button presses are not tracked.  The user should call ButtonAcknowledge immediately
    121          following this function to clear the state. If multiple tasks need the button 
    122          information, only the last function should call ButtonAcknowledge.
    123          
    124          Requires:
    125          - Button_asStatus[eButton_] is a valid index
    126          
    127          @param eButton_ is a valid button 
    128           
    129          Promises:
    130          - Returns TRUE if Button_asStatus[eButton_].bNewPressFlag is TRUE 
    131          - Otherwise returns FALSE
    132          
    133          */

   \                                 In section .text, align 2, keep-with-next
    134          bool WasButtonPressed(ButtonNameType eButton_)
    135          {
   \                     WasButtonPressed: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
    136            if( Button_asStatus[(u8)eButton_].bNewPressFlag == TRUE)
   \   00000004   0x....             LDR      R0,??DataTable9_1
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x220C             MOVS     R2,#+12
   \   0000000A   0x434A             MULS     R2,R1,R2
   \   0000000C   0x1880             ADDS     R0,R0,R2
   \   0000000E   0x7840             LDRB     R0,[R0, #+1]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ      ??WasButtonPressed_0
    137            {
    138              return(TRUE);
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B        ??WasButtonPressed_1
    139            }
    140            else
    141            {
    142              return(FALSE);
   \                     ??WasButtonPressed_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??WasButtonPressed_1: (+1)
   \   0000001A   0xBD00             POP      {PC}             ;; return
    143            }
    144          
    145          } /* end WasButtonPressed() */
    146          
    147          
    148          /*!----------------------------------------------------------------------------------------------------------------------
    149          @fn void ButtonAcknowledge(ButtonNameType eButton_)
    150          
    151          @brief Clears the "New Press" flag of a button so WasButtonPressed() no longer returns TRUE
    152          unless a new button press occurs.
    153          
    154          This function is generally always called after WasButtonPressed() returns TRUE unless 
    155          it is known that other tasks may need the button pressed information.
    156          
    157          Requires:
    158          @param eButton_ is a valid button index
    159           
    160          Promises:
    161          - The flag at Button_asStatus[eButton_].bNewPressFlag is set to FALSE
    162          
    163          */

   \                                 In section .text, align 2, keep-with-next
    164          void ButtonAcknowledge(ButtonNameType eButton_)
    165          {
    166            Button_asStatus[(u8)eButton_].bNewPressFlag = FALSE;
   \                     ButtonAcknowledge: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR      R2,??DataTable9_1
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x230C             MOVS     R3,#+12
   \   00000008   0x4343             MULS     R3,R0,R3
   \   0000000A   0x18D2             ADDS     R2,R2,R3
   \   0000000C   0x7051             STRB     R1,[R2, #+1]
    167          
    168          } /* end ButtonAcknowledge() */
   \   0000000E   0x4770             BX       LR               ;; return
    169          
    170          
    171          /*!----------------------------------------------------------------------------------------------------------------------
    172          @fn bool IsButtonHeld(ButtonNameType eButton_, u32 u32ButtonHeldTime_)
    173          
    174          @brief Queries to see if a button has been held for a certain time.  
    175          
    176          The button must still be pressed when this function is called if it is to return TRUE.
    177          This is a non-latching function.
    178          
    179          Requires:
    180          @param eButton_ is a valid button index
    181          @param u32ButtonHeldTime is a time in ms 
    182           
    183          Promises:
    184          - Returns TRUE if eButton_ has been held longer than u32ButtonHeldTime_
    185          - Otherwise returns FALSE
    186          
    187          */

   \                                 In section .text, align 2, keep-with-next
    188          bool IsButtonHeld(ButtonNameType eButton_, u32 u32ButtonHeldTime_)
    189          {
   \                     IsButtonHeld: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    190           if( (Button_asStatus[(u8)eButton_].eCurrentState == PRESSED) && 
    191                IsTimeUp(&Button_asStatus[eButton_].u32DebounceTimeStart, u32ButtonHeldTime_ ) )
   \   00000006   0x....             LDR      R0,??DataTable9_1
   \   00000008   0xB2ED             UXTB     R5,R5
   \   0000000A   0x210C             MOVS     R1,#+12
   \   0000000C   0x4369             MULS     R1,R5,R1
   \   0000000E   0x1840             ADDS     R0,R0,R1
   \   00000010   0x7880             LDRB     R0,[R0, #+2]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD10C             BNE      ??IsButtonHeld_0
   \   00000016   0x0021             MOVS     R1,R4
   \   00000018   0x....             LDR      R0,??DataTable9_1
   \   0000001A   0xB2ED             UXTB     R5,R5
   \   0000001C   0x220C             MOVS     R2,#+12
   \   0000001E   0x436A             MULS     R2,R5,R2
   \   00000020   0x1880             ADDS     R0,R0,R2
   \   00000022   0x1D00             ADDS     R0,R0,#+4
   \   00000024   0x.... 0x....      BL       IsTimeUp
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ      ??IsButtonHeld_0
    192           {
    193             return(TRUE);
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE000             B        ??IsButtonHeld_1
    194           }
    195           else
    196           {
    197             return(FALSE);
   \                     ??IsButtonHeld_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??IsButtonHeld_1: (+1)
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    198           }
    199          
    200          } /* end IsButtonHeld() */
    201          
    202          
    203          /*--------------------------------------------------------------------------------------------------------------------*/
    204          /* Protected Functions */
    205          /*--------------------------------------------------------------------------------------------------------------------*/
    206          
    207          /*!----------------------------------------------------------------------------------------------------------------------
    208          @fn void ButtonInitialize(void)
    209          
    210          @brief Runs required initialization for the task.  
    211          
    212          Should only be called once in main init section.
    213          Configures the button system for the product including enabling button GPIO interrupts.  
    214          
    215          Requires:
    216          - GPIO configuration is already complete for all button inputs
    217          - Button interrupt initializations and handler functions are ready
    218           
    219          Promises:
    220          - G_abButtonDebounceActive, LGaeButtonPreviousState and Button_aeCurrentState 
    221            are intialized
    222          - GGstButtonTrackballPosition fields are all initialized to default values
    223          - The button state machine is initialized to Idle
    224          
    225          */

   \                                 In section .text, align 2, keep-with-next
    226          void ButtonInitialize(void)
    227          {
   \                     ButtonInitialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    228            /* Setup default data and interrupts for all of the buttons in the system */
    229            for(u8 i = 0; i < U8_TOTAL_BUTTONS; i++)
   \   00000002   0x2400             MOVS     R4,#+0
   \                     ??ButtonInitialize_0: (+1)
   \   00000004   0xB2E4             UXTB     R4,R4
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD13C             BNE      ??ButtonInitialize_1
    230            {
    231              /* Default status data */
    232              Button_asStatus[i].bNewPressFlag = FALSE;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x....             LDR      R1,??DataTable9_1
   \   0000000E   0xB2E4             UXTB     R4,R4
   \   00000010   0x220C             MOVS     R2,#+12
   \   00000012   0x4362             MULS     R2,R4,R2
   \   00000014   0x1889             ADDS     R1,R1,R2
   \   00000016   0x7048             STRB     R0,[R1, #+1]
    233              Button_asStatus[i].eCurrentState = RELEASED;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR      R1,??DataTable9_1
   \   0000001C   0xB2E4             UXTB     R4,R4
   \   0000001E   0x220C             MOVS     R2,#+12
   \   00000020   0x4362             MULS     R2,R4,R2
   \   00000022   0x1889             ADDS     R1,R1,R2
   \   00000024   0x7088             STRB     R0,[R1, #+2]
    234              Button_asStatus[i].eNewState     = RELEASED;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR      R1,??DataTable9_1
   \   0000002A   0xB2E4             UXTB     R4,R4
   \   0000002C   0x220C             MOVS     R2,#+12
   \   0000002E   0x4362             MULS     R2,R4,R2
   \   00000030   0x1889             ADDS     R1,R1,R2
   \   00000032   0x70C8             STRB     R0,[R1, #+3]
    235              Button_asStatus[i].u32TimeStamp  = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x....             LDR      R1,??DataTable9_1
   \   00000038   0xB2E4             UXTB     R4,R4
   \   0000003A   0x220C             MOVS     R2,#+12
   \   0000003C   0x4362             MULS     R2,R4,R2
   \   0000003E   0x1889             ADDS     R1,R1,R2
   \   00000040   0x6088             STR      R0,[R1, #+8]
    236          
    237              /* Event configuration for toggle events */
    238              nrf_gpiote_event_config(G_asBspButtonConfigurations[i].eChannelNumber, 
    239                                      G_asBspButtonConfigurations[i].u8PinNumber, 
    240                                      NRF_GPIOTE_POLARITY_TOGGLE);
   \   00000042   0x2203             MOVS     R2,#+3
   \   00000044   0x....             LDR      R0,??DataTable9_2
   \   00000046   0xB2E4             UXTB     R4,R4
   \   00000048   0x210C             MOVS     R1,#+12
   \   0000004A   0x4361             MULS     R1,R4,R1
   \   0000004C   0x1840             ADDS     R0,R0,R1
   \   0000004E   0x7A01             LDRB     R1,[R0, #+8]
   \   00000050   0x....             LDR      R0,??DataTable9_2
   \   00000052   0xB2E4             UXTB     R4,R4
   \   00000054   0x230C             MOVS     R3,#+12
   \   00000056   0x4363             MULS     R3,R4,R3
   \   00000058   0x18C0             ADDS     R0,R0,R3
   \   0000005A   0x7A80             LDRB     R0,[R0, #+10]
   \   0000005C   0x.... 0x....      BL       nrf_gpiote_event_config
    241              
    242              /* GPIOE Interrupt setup */
    243              if(G_asBspButtonConfigurations[i].eChannelNumber != GPIOE_NO_CHANNEL)
   \   00000060   0x....             LDR      R0,??DataTable9_2
   \   00000062   0xB2E4             UXTB     R4,R4
   \   00000064   0x210C             MOVS     R1,#+12
   \   00000066   0x4361             MULS     R1,R4,R1
   \   00000068   0x1840             ADDS     R0,R0,R1
   \   0000006A   0x7A80             LDRB     R0,[R0, #+10]
   \   0000006C   0x2804             CMP      R0,#+4
   \   0000006E   0xD007             BEQ      ??ButtonInitialize_2
    244              {
    245                NRF_GPIOTE->INTENSET = G_asBspButtonConfigurations[i].u32GpioeChannelBit; 
   \   00000070   0x....             LDR      R0,??DataTable9_2
   \   00000072   0xB2E4             UXTB     R4,R4
   \   00000074   0x210C             MOVS     R1,#+12
   \   00000076   0x4361             MULS     R1,R4,R1
   \   00000078   0x1840             ADDS     R0,R0,R1
   \   0000007A   0x6840             LDR      R0,[R0, #+4]
   \   0000007C   0x....             LDR      R1,??DataTable9_3  ;; 0x40006304
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    246              }
    247            }
   \                     ??ButtonInitialize_2: (+1)
   \   00000080   0x1C64             ADDS     R4,R4,#+1
   \   00000082   0xE7BF             B        ??ButtonInitialize_0
    248            
    249            /* Init complete: set function pointer */
    250            Button_pfnStateMachine = ButtonSM_Idle;
   \                     ??ButtonInitialize_1: (+1)
   \   00000084   0x....             LDR      R0,??DataTable9_4
   \   00000086   0x....             LDR      R1,??DataTable9_5
   \   00000088   0x6008             STR      R0,[R1, #+0]
    251            
    252           } /* end ButtonInitialize() */
   \   0000008A   0xBD10             POP      {R4,PC}          ;; return
    253          
    254          
    255          /*----------------------------------------------------------------------------------------------------------------------
    256          Function ButtonRunActiveState()
    257          
    258          Description:
    259          Selects and runs one iteration of the current state in the state machine.
    260          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    261          may take 1ms / n to execute.
    262          
    263          Requires:
    264            - State machine function pointer points at current state
    265          
    266          Promises:
    267            - Calls the function to pointed by the state machine function pointer
    268          */

   \                                 In section .text, align 2, keep-with-next
    269          void ButtonRunActiveState(void)
    270          {
   \                     ButtonRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    271            Button_pfnStateMachine();
   \   00000002   0x....             LDR      R0,??DataTable9_5
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    272          
    273          } /* end ButtonRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    274          
    275          
    276          
    277          /*!----------------------------------------------------------------------------------------------------------------------
    278          @fn void ButtonStartDebounce(u8 u8ButtonIndex_)
    279          
    280          @brief Called only from ISR: sets the "debounce active" flag and debounce start time  
    281          
    282          Requires:
    283          - Only the GPIOE ISR should call this function
    284          
    285          @param u32BitPosition_ is a SINGLE bit and actual button location on which to start debouncing
    286          
    287          Promises:
    288          - If the indicated button is found in G_asBspButtonConfigurations, then the
    289          corresponding interrupt is disabled and debounce information is set in Button_asStatus
    290          
    291          */

   \                                 In section .text, align 2, keep-with-next
    292          void ButtonStartDebounce(u32 u32BitPosition_)
    293          {
   \                     ButtonStartDebounce: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    294            u8 u8Button = 0;
   \   00000002   0x2100             MOVS     R1,#+0
    295            
    296            /* Parse through to find the button */
    297            for(u8 i = 0; i < U8_TOTAL_BUTTONS; i++)
   \   00000004   0x2200             MOVS     R2,#+0
   \                     ??ButtonStartDebounce_0: (+1)
   \   00000006   0xB2D2             UXTB     R2,R2
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD10A             BNE      ??ButtonStartDebounce_1
    298            {
    299              if(G_asBspButtonConfigurations[i].u32BitPosition == u32BitPosition_)
   \   0000000C   0x....             LDR      R3,??DataTable9_2
   \   0000000E   0xB2D2             UXTB     R2,R2
   \   00000010   0x240C             MOVS     R4,#+12
   \   00000012   0x4354             MULS     R4,R2,R4
   \   00000014   0x591B             LDR      R3,[R3, R4]
   \   00000016   0x4283             CMP      R3,R0
   \   00000018   0xD101             BNE      ??ButtonStartDebounce_2
    300              {
    301                u8Button = i;
   \   0000001A   0x0011             MOVS     R1,R2
    302                break;
   \   0000001C   0xE001             B        ??ButtonStartDebounce_1
    303              }
    304            }
   \                     ??ButtonStartDebounce_2: (+1)
   \   0000001E   0x1C52             ADDS     R2,R2,#+1
   \   00000020   0xE7F1             B        ??ButtonStartDebounce_0
    305            
    306            /* If the button has been found, disable the interrupt and update debounce status */
    307            if(u8Button != NOBUTTON)
   \                     ??ButtonStartDebounce_1: (+1)
   \   00000022   0xB2C9             UXTB     R1,R1
   \   00000024   0x2901             CMP      R1,#+1
   \   00000026   0xD020             BEQ      ??ButtonStartDebounce_3
    308            {
    309              NRF_GPIOTE->INTENCLR = G_asBspButtonConfigurations[u8Button].u32GpioeChannelBit;
   \   00000028   0x....             LDR      R2,??DataTable9_2
   \   0000002A   0xB2C9             UXTB     R1,R1
   \   0000002C   0x230C             MOVS     R3,#+12
   \   0000002E   0x434B             MULS     R3,R1,R3
   \   00000030   0x18D2             ADDS     R2,R2,R3
   \   00000032   0x6852             LDR      R2,[R2, #+4]
   \   00000034   0x....             LDR      R3,??DataTable9_6  ;; 0x40006308
   \   00000036   0x601A             STR      R2,[R3, #+0]
    310              NRF_GPIOTE->EVENTS_IN[G_asBspButtonConfigurations[u8Button].eChannelNumber] = 0;   
   \   00000038   0x....             LDR      R2,??DataTable9  ;; 0x40006100
   \   0000003A   0x....             LDR      R3,??DataTable9_2
   \   0000003C   0xB2C9             UXTB     R1,R1
   \   0000003E   0x240C             MOVS     R4,#+12
   \   00000040   0x434C             MULS     R4,R1,R4
   \   00000042   0x191B             ADDS     R3,R3,R4
   \   00000044   0x7A9B             LDRB     R3,[R3, #+10]
   \   00000046   0x2404             MOVS     R4,#+4
   \   00000048   0x4363             MULS     R3,R4,R3
   \   0000004A   0x2400             MOVS     R4,#+0
   \   0000004C   0x50D4             STR      R4,[R2, R3]
    311          
    312              Button_asStatus[u8Button].bDebounceActive = TRUE;
   \   0000004E   0x2201             MOVS     R2,#+1
   \   00000050   0x....             LDR      R3,??DataTable9_1
   \   00000052   0xB2C9             UXTB     R1,R1
   \   00000054   0x240C             MOVS     R4,#+12
   \   00000056   0x434C             MULS     R4,R1,R4
   \   00000058   0x551A             STRB     R2,[R3, R4]
    313              Button_asStatus[u8Button].u32DebounceTimeStart = G_u32SystemTime1ms;
   \   0000005A   0x....             LDR      R2,??DataTable9_7
   \   0000005C   0x6812             LDR      R2,[R2, #+0]
   \   0000005E   0x....             LDR      R3,??DataTable9_1
   \   00000060   0xB2C9             UXTB     R1,R1
   \   00000062   0x240C             MOVS     R4,#+12
   \   00000064   0x434C             MULS     R4,R1,R4
   \   00000066   0x191B             ADDS     R3,R3,R4
   \   00000068   0x605A             STR      R2,[R3, #+4]
    314            }
    315            
    316          } /* end ButtonStartDebounce() */
   \                     ??ButtonStartDebounce_3: (+1)
   \   0000006A   0xBD10             POP      {R4,PC}          ;; return
    317          
    318          
    319          
    320          /*------------------------------------------------------------------------------------------------------------------*/
    321          /*! @privatesection */                                                                                            
    322          /*--------------------------------------------------------------------------------------------------------------------*/
    323          
    324          
    325          /***********************************************************************************************************************
    326          State Machine Function Definitions
    327          
    328          The button state machine monitors button activity and manages debouncing and
    329          maintaining the global button states.
    330          ***********************************************************************************************************************/
    331          
    332          /*!-------------------------------------------------------------------------------------------------------------------
    333          @fn static void ButtonSM_Idle(void)
    334          
    335          @brief Look for at least one button to enter debouncing state
    336          */

   \                                 In section .text, align 2, keep-with-next
    337          static void ButtonSM_Idle(void)                
    338          {
   \                     ButtonSM_Idle: (+1)
   \   00000000   0xB500             PUSH     {LR}
    339            for(u8 i = 0; i < U8_TOTAL_BUTTONS; i++)
   \   00000002   0x2000             MOVS     R0,#+0
   \                     ??ButtonSM_Idle_0: (+1)
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD10C             BNE      ??ButtonSM_Idle_1
    340            {
    341              if(Button_asStatus[i].bDebounceActive)
   \   0000000A   0x....             LDR      R1,??DataTable9_1
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x220C             MOVS     R2,#+12
   \   00000010   0x4342             MULS     R2,R0,R2
   \   00000012   0x5C89             LDRB     R1,[R1, R2]
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD003             BEQ      ??ButtonSM_Idle_2
    342              {
    343                Button_pfnStateMachine = ButtonSM_ButtonActive;
   \   00000018   0x....             LDR      R0,??DataTable9_8
   \   0000001A   0x....             LDR      R1,??DataTable9_5
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    344                break;
   \   0000001E   0xE001             B        ??ButtonSM_Idle_1
    345              }
    346            }
   \                     ??ButtonSM_Idle_2: (+1)
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xE7EF             B        ??ButtonSM_Idle_0
    347            
    348          } /* end ButtonSM_Idle(void) */
   \                     ??ButtonSM_Idle_1: (+1)
   \   00000024   0xBD00             POP      {PC}             ;; return
    349          
    350          
    351          
    352          /*!-------------------------------------------------------------------------------------------------------------------
    353          @fn static void ButtonSM_ButtonActive(void)
    354          
    355          @brief Process each button that is debouncing.
    356          
    357          Time out the debounce period and set the "pressed" state if button action is confirmed.
    358          Manage the hold timers.
    359          */

   \                                 In section .text, align 2, keep-with-next
    360          static void ButtonSM_ButtonActive(void)         
    361          {
   \                     ButtonSM_ButtonActive: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    362          //  u32 *pu32PortAddress;
    363          //  u32 *pu32InterruptAddress;
    364            u32 u32Input;
    365          
    366            /* Start by resetting back to Idle in case no buttons are active */
    367            Button_pfnStateMachine = ButtonSM_Idle;
   \   00000002   0x....             LDR      R0,??DataTable9_4
   \   00000004   0x....             LDR      R1,??DataTable9_5
   \   00000006   0x6008             STR      R0,[R1, #+0]
    368          
    369            /* Check for buttons that are debouncing */
    370            for(u8 i = 0; i < U8_TOTAL_BUTTONS; i++)
   \   00000008   0x2400             MOVS     R4,#+0
   \                     ??ButtonSM_ButtonActive_0: (+1)
   \   0000000A   0xB2E4             UXTB     R4,R4
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD179             BNE      ??ButtonSM_ButtonActive_1
    371            {
    372              /* Load address offsets for the current button */
    373          //    pu32PortAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_PDSR) + G_asBspButtonConfigurations[i].ePort);
    374          //    pu32InterruptAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_IER) + G_asBspButtonConfigurations[i].ePort);
    375              
    376              /* Check if the current button is debouncing */
    377              if( Button_asStatus[i].bDebounceActive )
   \   00000010   0x....             LDR      R0,??DataTable9_1
   \   00000012   0xB2E4             UXTB     R4,R4
   \   00000014   0x210C             MOVS     R1,#+12
   \   00000016   0x4361             MULS     R1,R4,R1
   \   00000018   0x5C40             LDRB     R0,[R0, R1]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD070             BEQ      ??ButtonSM_ButtonActive_2
    378              {
    379                /* Still have an active button */
    380                Button_pfnStateMachine = ButtonSM_ButtonActive;
   \   0000001E   0x....             LDR      R0,??DataTable9_8
   \   00000020   0x....             LDR      R1,??DataTable9_5
   \   00000022   0x6008             STR      R0,[R1, #+0]
    381                
    382                /* Check if debounce period is over */
    383                if( IsTimeUp(&Button_asStatus[i].u32DebounceTimeStart, U32_BUTTON_DEBOUNCE_TIME) )
   \   00000024   0x210A             MOVS     R1,#+10
   \   00000026   0x....             LDR      R0,??DataTable9_1
   \   00000028   0xB2E4             UXTB     R4,R4
   \   0000002A   0x220C             MOVS     R2,#+12
   \   0000002C   0x4362             MULS     R2,R4,R2
   \   0000002E   0x1880             ADDS     R0,R0,R2
   \   00000030   0x1D00             ADDS     R0,R0,#+4
   \   00000032   0x.... 0x....      BL       IsTimeUp
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD062             BEQ      ??ButtonSM_ButtonActive_2
    384                {
    385                  /* Read the pin state and invert for ACTIVE_LOW */
    386                  u32Input = NRF_GPIO->IN;
   \   0000003A   0x....             LDR      R0,??DataTable9_9  ;; 0x50000510
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x0005             MOVS     R5,R0
    387                  if(G_asBspButtonConfigurations[i].eActiveState == ACTIVE_LOW)
   \   00000040   0x....             LDR      R0,??DataTable9_2
   \   00000042   0xB2E4             UXTB     R4,R4
   \   00000044   0x210C             MOVS     R1,#+12
   \   00000046   0x4361             MULS     R1,R4,R1
   \   00000048   0x1840             ADDS     R0,R0,R1
   \   0000004A   0x7A40             LDRB     R0,[R0, #+9]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD101             BNE      ??ButtonSM_ButtonActive_3
    388                  {
    389                    u32Input = ~u32Input;
   \   00000050   0x43E8             MVNS     R0,R5
   \   00000052   0x0005             MOVS     R5,R0
    390                  }
    391                  
    392                  /* Mask the bit of interest to check its state */
    393                  if( u32Input & G_asBspButtonConfigurations[i].u32BitPosition )
   \                     ??ButtonSM_ButtonActive_3: (+1)
   \   00000054   0x....             LDR      R0,??DataTable9_2
   \   00000056   0xB2E4             UXTB     R4,R4
   \   00000058   0x210C             MOVS     R1,#+12
   \   0000005A   0x4361             MULS     R1,R4,R1
   \   0000005C   0x5840             LDR      R0,[R0, R1]
   \   0000005E   0x4028             ANDS     R0,R0,R5
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD007             BEQ      ??ButtonSM_ButtonActive_4
    394                  {          
    395                    Button_asStatus[i].eNewState = PRESSED;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x....             LDR      R1,??DataTable9_1
   \   00000068   0xB2E4             UXTB     R4,R4
   \   0000006A   0x220C             MOVS     R2,#+12
   \   0000006C   0x4362             MULS     R2,R4,R2
   \   0000006E   0x1889             ADDS     R1,R1,R2
   \   00000070   0x70C8             STRB     R0,[R1, #+3]
   \   00000072   0xE006             B        ??ButtonSM_ButtonActive_5
    396                  }
    397                  else
    398                  {
    399                    Button_asStatus[i].eNewState = RELEASED;
   \                     ??ButtonSM_ButtonActive_4: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x....             LDR      R1,??DataTable9_1
   \   00000078   0xB2E4             UXTB     R4,R4
   \   0000007A   0x220C             MOVS     R2,#+12
   \   0000007C   0x4362             MULS     R2,R4,R2
   \   0000007E   0x1889             ADDS     R1,R1,R2
   \   00000080   0x70C8             STRB     R0,[R1, #+3]
    400                  }
    401                  
    402                  /* Update if the button state has changed */
    403                  if( Button_asStatus[i].eNewState != Button_asStatus[i].eCurrentState )
   \                     ??ButtonSM_ButtonActive_5: (+1)
   \   00000082   0x....             LDR      R0,??DataTable9_1
   \   00000084   0xB2E4             UXTB     R4,R4
   \   00000086   0x210C             MOVS     R1,#+12
   \   00000088   0x4361             MULS     R1,R4,R1
   \   0000008A   0x1840             ADDS     R0,R0,R1
   \   0000008C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000008E   0x....             LDR      R1,??DataTable9_1
   \   00000090   0xB2E4             UXTB     R4,R4
   \   00000092   0x220C             MOVS     R2,#+12
   \   00000094   0x4362             MULS     R2,R4,R2
   \   00000096   0x1889             ADDS     R1,R1,R2
   \   00000098   0x7889             LDRB     R1,[R1, #+2]
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xD022             BEQ      ??ButtonSM_ButtonActive_6
    404                  {
    405                    Button_asStatus[i].eCurrentState = Button_asStatus[i].eNewState;
   \   0000009E   0x....             LDR      R0,??DataTable9_1
   \   000000A0   0xB2E4             UXTB     R4,R4
   \   000000A2   0x210C             MOVS     R1,#+12
   \   000000A4   0x4361             MULS     R1,R4,R1
   \   000000A6   0x1840             ADDS     R0,R0,R1
   \   000000A8   0x78C0             LDRB     R0,[R0, #+3]
   \   000000AA   0x....             LDR      R1,??DataTable9_1
   \   000000AC   0xB2E4             UXTB     R4,R4
   \   000000AE   0x220C             MOVS     R2,#+12
   \   000000B0   0x4362             MULS     R2,R4,R2
   \   000000B2   0x1889             ADDS     R1,R1,R2
   \   000000B4   0x7088             STRB     R0,[R1, #+2]
    406                    
    407                    /* If the new state is PRESSED, update the new press flag */
    408                    if(Button_asStatus[i].eCurrentState == PRESSED)
   \   000000B6   0x....             LDR      R0,??DataTable9_1
   \   000000B8   0xB2E4             UXTB     R4,R4
   \   000000BA   0x210C             MOVS     R1,#+12
   \   000000BC   0x4361             MULS     R1,R4,R1
   \   000000BE   0x1840             ADDS     R0,R0,R1
   \   000000C0   0x7880             LDRB     R0,[R0, #+2]
   \   000000C2   0x2801             CMP      R0,#+1
   \   000000C4   0xD10E             BNE      ??ButtonSM_ButtonActive_6
    409                    {
    410                      Button_asStatus[i].bNewPressFlag = TRUE;
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x....             LDR      R1,??DataTable9_1
   \   000000CA   0xB2E4             UXTB     R4,R4
   \   000000CC   0x220C             MOVS     R2,#+12
   \   000000CE   0x4362             MULS     R2,R4,R2
   \   000000D0   0x1889             ADDS     R1,R1,R2
   \   000000D2   0x7048             STRB     R0,[R1, #+1]
    411                      Button_asStatus[i].u32TimeStamp  = G_u32SystemTime1ms;
   \   000000D4   0x....             LDR      R0,??DataTable9_7
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0x....             LDR      R1,??DataTable9_1
   \   000000DA   0xB2E4             UXTB     R4,R4
   \   000000DC   0x220C             MOVS     R2,#+12
   \   000000DE   0x4362             MULS     R2,R4,R2
   \   000000E0   0x1889             ADDS     R1,R1,R2
   \   000000E2   0x6088             STR      R0,[R1, #+8]
    412                    }
    413                  }
    414          
    415                  /* Regardless of a good press or not, clear the debounce active flag and re-enable the interrupts */
    416                  Button_asStatus[i].bDebounceActive = FALSE;
   \                     ??ButtonSM_ButtonActive_6: (+1)
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x....             LDR      R1,??DataTable9_1
   \   000000E8   0xB2E4             UXTB     R4,R4
   \   000000EA   0x220C             MOVS     R2,#+12
   \   000000EC   0x4362             MULS     R2,R4,R2
   \   000000EE   0x5488             STRB     R0,[R1, R2]
    417                  NRF_GPIOTE->INTENSET = G_asBspButtonConfigurations[i].u32GpioeChannelBit;
   \   000000F0   0x....             LDR      R0,??DataTable9_2
   \   000000F2   0xB2E4             UXTB     R4,R4
   \   000000F4   0x210C             MOVS     R1,#+12
   \   000000F6   0x4361             MULS     R1,R4,R1
   \   000000F8   0x1840             ADDS     R0,R0,R1
   \   000000FA   0x6840             LDR      R0,[R0, #+4]
   \   000000FC   0x....             LDR      R1,??DataTable9_3  ;; 0x40006304
   \   000000FE   0x6008             STR      R0,[R1, #+0]
    418                  
    419                } /* end if( IsTimeUp...) */
    420              } /* end if(Button_asStatus[i].bDebounceActive) */
    421            } /* end for (u8 i = 0; i < U8_TOTAL_BUTTONS; i++) */
   \                     ??ButtonSM_ButtonActive_2: (+1)
   \   00000100   0x1C64             ADDS     R4,R4,#+1
   \   00000102   0xE782             B        ??ButtonSM_ButtonActive_0
    422            
    423          } /* end ButtonSM_ButtonActive() */
   \                     ??ButtonSM_ButtonActive_1: (+1)
   \   00000104   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x40006510         DC32     0x40006510

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40006100         DC32     0x40006100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     Button_asStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     G_asBspButtonConfigurations

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40006304         DC32     0x40006304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     ButtonSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     Button_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x40006308         DC32     0x40006308

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     ButtonSM_ButtonActive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x50000510         DC32     0x50000510
    424          
    425          
    426          
    427          
    428          
    429          /*--------------------------------------------------------------------------------------------------------------------*/
    430          /* End of File */
    431          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ButtonAcknowledge
       8   ButtonInitialize
         8   -> nrf_gpiote_event_config
       8   ButtonRunActiveState
         8   -- Indirect call
      16   ButtonSM_ButtonActive
        16   -> IsTimeUp
       4   ButtonSM_Idle
       8   ButtonStartDebounce
      16   IsButtonHeld
        16   -> IsTimeUp
       4   IsButtonPressed
       4   WasButtonPressed
       8   nrf_gpiote_event_config


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      16  ButtonAcknowledge
     140  ButtonInitialize
      10  ButtonRunActiveState
     262  ButtonSM_ButtonActive
      38  ButtonSM_Idle
     108  ButtonStartDebounce
      12  Button_asStatus
       4  Button_pfnStateMachine
      52  IsButtonHeld
      28  IsButtonPressed
      28  WasButtonPressed
      42  nrf_gpiote_event_config

 
  16 bytes in section .bss
 768 bytes in section .text
 
 768 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
